{% load staticfiles %}
<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<body>
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/spin.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/jquery-ui.min.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/component.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/component-button.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/modal-component.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/normalize.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/bearbull.css' %}">
<script src="{% static 'jquery-ui-1.11.4.custom/external/jquery/jquery.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/jquery-ui.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/jquery.ui.slider.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/d3.min.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/external/jquery/d3-legend.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/dataManipulator.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/snap.svg-min.js' %}"></script>

<!-- A LOT of CSS we have used is from tympanus.net .. in case you like them, you should definitely check out the site. We think its beautiful :) -->

<script>
//global VARIABLES
	
	window.master_array = new Array();	  
	window.bm_array = new Array();	  
	window.bm_Data_ = [];
	window.bins = [0.13,0.12,0.11,0.1,0.09,0.08,0.07,0.06,0.05,0.04,0.03,0.02,0.01,0,-0.01,-0.02,-0.03,-0.04,-0.05,-0.06,-0.07,-0.08,-0.09,-0.1,-0.11,-0.12,-0.13];
	//this will store the fund selected by the user
	window.current_MF_Data_ = [];
	window._BM_MF_FromDt_idx = -1;
	window._BM_MF_ToDt_idx = -1; 
	var colors = d3.scale.category20();
	//to be read from a static file
	window.MFVsBMHeight = (300*screen.width)/(1920);
	//since we have the graph continers as 67% of the width scale graph width in 1/3 proportion and subtract left and right margin
	window.MFVsBMWidth = ((screen.width)/3)-60;
	window.dispCircleRadius = 5;
	window.dispBMName = '';	
	window.dispMFName = '';
	window.isDragging = false;
	window.bnch = 'CNX Nifty';
	window.cmpAsset = "";
	window.assetType = "index";
	window.barWidth = 0.0;
	window.assetColor = "#7D1935";
	window.cmpassetColor = "steelblue";
	window.currPhase = 'HV';
	window.HVPhases = new Array("FLAT1","FLAT2");
	window.LVPhases = new Array("BULL2","BULL3"); 
	window.ajaxInd = 1;

	window._BM_MF_FromDt_idx = -1;
        window._BM_MF_ToDt_idx = -1;


        window.Mnth = {};
        window.MnthRev = {};
	window.storeAreaData = {};

        Mnth["Jan"]='01';
        Mnth["Feb"]='02';
        Mnth["Mar"]='03';
        Mnth["Apr"]='04';
        Mnth["May"]='05';
        Mnth["Jun"]='06';
        Mnth["Jul"]='07';
        Mnth["Aug"]='08';
        Mnth["Sep"]='09';
        Mnth["Oct"]='10';
        Mnth["Nov"]='11';
        Mnth["Dec"]='12';


        MnthRev[1]='Jan';
        MnthRev[2]='Feb';
        MnthRev[3]='Mar';
        MnthRev[4]='Apr';
        MnthRev[5]='May';
        MnthRev[6]='Jun';
        MnthRev[7]='Jul';
        MnthRev[8]='Aug';
        MnthRev[9]='Sep';
        MnthRev[10]='Oct';
        MnthRev[11]='Nov';
        MnthRev[12]='Dec';
	
	
	//given that both BM and MF will have the same dt range 
	//we can read the current BM values itself
	function findIndex(findDt){
		
		for(ctr = 0 ;ctr < bm_Data_.length; ctr++){
			if( (bm_Data_[ctr].dt).getTime() >= findDt.getTime() )
				return ctr;
		}
		return -1;
	}

	function genMsg(){
		//for now lets use averages of IQR and returns ..else lotsa if loops
		var retBetterOrWorse = ''
		var riskBetterOrWorse = ''
		var retBetterOrWorse1 = ''
		var riskBetterOrWorse1 = ''
		//first section for HV ..better or worse avg returns fr a phase as copared to the benchmark
		if ( (HVBMRet/2) > (HVAssetRet/2) && ((HVBMRet/2) - (HVAssetRet/2)) > 0.1 ){
			retBetterOrWorse = " lower ";	
		} 
		else if ( (HVBMRet/2) > (HVAssetRet/2) && ((HVBMRet/2) - (HVAssetRet/2)) < 0.1 )
			retBetterOrWorse = " similar ";	
		else if ( (HVBMRet/2) < (HVAssetRet/2) && ((HVBMRet/2) - (HVAssetRet/2)) < -0.1 )
                        retBetterOrWorse = " similar ";
		else
			retBetterOrWorse = " higher ";
		
		if ( HVBMIQR/2 > HVAssetIQR/2)
			riskBetterOrWorse = " lower ";
		else if ( HVBMIQR/2 < HVAssetIQR/2)
                        riskBetterOrWorse = " higher ";

		var HdrPara = 'The '+assetType+' '+cmpAsset+' has '+riskBetterOrWorse+' volatility during periods of High Volatility as compared to the benchmark. ';
		var Dtl =  'Looking at the High Volatility phases (Risk and return graphs to the LEFT ) one does notice the '+assetType+' '+cmpAsset+' has returns that are '+retBetterOrWorse+' as compared to the benchmark for a '+riskBetterOrWorse+' risk. ';
		
		//now generate message for Low Volatility		
		if ( (LVBMRet/2) > (LVAssetRet/2) && ((LVBMRet/2) - (LVAssetRet/2)) > 0.1 ){
			retBetterOrWorse1 = " lower ";	
		} 
		else if ( (LVBMRet/2) > (LVAssetRet/2) && ((LVBMRet/2) - (LVAssetRet/2)) < 0.1 )
			retBetterOrWorse1 = " similar ";	
		else if ( (LVBMRet/2) < (LVAssetRet/2) && ((LVBMRet/2) - (LVAssetRet/2)) < -0.1 )
                        retBetterOrWorse1 = " similar ";
		else
			retBetterOrWorse1 = " higher ";
		
		if ( LVBMIQR/2 > LVAssetIQR/2)
			riskBetterOrWorse1 = " lower ";
		else if ( LVBMIQR/2 < LVAssetIQR/2)
                        riskBetterOrWorse1 = " higher "; 


		HdrPara = HdrPara + 'During periods of Low Volatility it has '+riskBetterOrWorse1+' volatility . ';
		Dtl = Dtl + 'During Low Volatility (Risk and return graphs below) ,  it has returns that are '+retBetterOrWorse1+' as compared to the benchmark for a '+riskBetterOrWorse1+' risk. ';
		var addendum = '';	

		if(riskBetterOrWorse == " higher " && riskBetterOrWorse1 == " higher "){
			if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " higher "){
				Dtl = Dtl +  cmpAsset+' is a steady bet in BULLISH / LOW Volatility Phases and BEARISH phases.';
			}
			else if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " lower ")
				Dtl = Dtl + cmpAsset+' is a better bet in BULLISH / LOW Volatility Phases but NOT during BEARISH phases.';
			else
				Dtl = Dtl + cmpAsset+' is better avoided since it has higher volatility but lower returns across phases!!';
		}	
		else if(riskBetterOrWorse == " lower " && riskBetterOrWorse1 == " lower "){
			if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " higher "){
				Dtl = Dtl +  cmpAsset+' has high odds of beating the market in BULLISH / LOW Volatility Phases and BEARISH phases.';
			}
			else if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " lower ")
				Dtl = Dtl + cmpAsset+' is a safe bet in BULLISH / LOW Volatility Phases but NOT during BEARISH phases.';
		}	

	
		document.getElementById("Header1").innerHTML = 'Performance Commentary'; 	
		document.getElementById("Header1-Para").innerHTML = HdrPara +'. To know more hover over me ...'; 	
		document.getElementById("DetailedHeader1").innerHTML = Dtl;	
	}

	$(document).ready(function(){
		$("#loader-wrapper").hide();
		$("#info1").hide();
		$("#HDR").hide();
	});
	
	// to be called initially
	function initGlobalSetBM( passLL, passHist, passTS, passDist, passIQR, passIdxMinus){
			//FOR NOW use 0 index .. but we need to have a map
			// for MF data and bm index
			window.HVBMRet = 0.0;
			window.HVAssetRet = 0.0;
			window.LVBMRet = 0.0;
			window.LVAssetRet = 0.0;
			
			window.HVBMIQR = 0.0;
			window.HVAssetIQR = 0.0;
			window.LVBMIQR = 0.0;
			window.LVAssetIQR = 0.0;

			window.bm_Data_ = retDefaultBMData();
			//below 2 are python/django data
			if( passLL === undefined && passHist === undefined && passTS === undefined && passDist === undefined){
				window.tsList = {{ ll_list|safe  }};
				window.tsIdxList = {{ ll_idxminus |safe  }};
				window.histList = {{ hist|safe  }};
				window.timeSeries = {{ ll|safe  }};
				window.distSeries = {{ dist_ll|safe  }};
				window.IQRList = {{ IQR|safe  }};
			}	
			else{
				window.tsList = passLL;
                                window.histList = passHist;
                                window.timeSeries = passTS;
                                window.distSeries = passDist;
				window.IQRList = passIQR;
				window.tsIdxList = passIdxMinus;
			}

		
			if(tsList[0]['idx_name'] != bnch)
				cmpAsset = tsList[0]['idx_name'];
			else
				cmpAsset = tsList[1]['idx_name'];

			console.log('BATMAN '+cmpAsset+tsList[0]['idx_name']+'-'+tsList[1]['idx_name']+'-'+histList.length+'-'+histList['CNX Smallcap-FLAT2\r']);	
			window.timeSeriesDict = {};
			window.tSDict = {};
			window.timeSeriesZeroDict = {};
			window.histMaster = {};	
			initTS();
			initHIST();

			dispBMName = retDefaultBMName();
			var format = d3.time.format( "%d-%b-%y" );
			window.bm_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					d.closing = +d.closing;
				  });
			console.log(' JUST FINISHED !!');	  
		//first time user sees chart she should be able to see only 50% of the total time period	  
		//then these 2 values are continually updtd in dragslider function
			if(window._BM_MF_FromDt_idx == -1 && window._BM_MF_ToDt_idx == -1){
				_BM_MF_FromDt_idx = Math.round( bm_Data_.length*(0.5) );	
				_BM_MF_ToDt_idx = bm_Data_.length-1;	  
			}
		//initialize the autocomplete list
	}	 

	function refreshWithLatest( neo_data , ajaxOrLocal){
		//1 indicates its being called via ajax return function
		if( ajaxOrLocal == 1)
			initGlobalSetBM(neo_data['ll_list'],neo_data['hist'],neo_data['ll'],neo_data['dist_ll'],neo_data['IQR'], neo_data['ll_idxminus']);

		//d3.selectAll("path")
                //        .remove();	
		d3.selectAll(".bar").remove();
		d3.selectAll(".bar1").remove();

		_reScaleBM_MF_axes( ".chart2");
		_reScaleBM_MF_axes( ".chart22");
		

		//first numeric arg is uper /lower and the 2nd one indicates if its a screen refresh
		genHist(".histFlat1", 0);
	
		//call paint legend	
		paintbnch();
		paintcmp();

		//call linechart 4th quad refresh
		_drawBM_MF_axes ("#whlsLineChart", ".lastLine", tSDict, bnch , cmpAsset, "#dragslider-range", "#FromDt", "#ToDt" );
		
		genMsg();
	
	}

	function retDailyData(  dt, area){
		locNm = '';

		//check for sat and sunday ...if so pass the function day-1 or 2 accordingly
		if (dt.getDay() == 6)
			dt = new Date(dt.setDate(dt.getDate() - 1));
		else if (dt.getDay() == 0)
                        dt = new Date(dt.setDate(dt.getDate() - 2));

		locData = storeAreaData[ [area] ];
		data = locData.BM;
		dataAss = locData.ASS;
		
                for(ctr = 0 ; ctr < data.length; ctr++)
                {
                        lcDt = data[ctr].dt;
                        if ( dt.getFullYear() == lcDt.getFullYear() && dt.getMonth() == lcDt.getMonth() && dt.getDate() == lcDt.getDate()  ) {
                                        var per = data[ctr];
                                        var per1 = dataAss[ctr];
                                         ret = Math.round(per.cumuChg*100*100)/100 ;
                                         ret1 = Math.round(per1.cumuChg*100*100)/100 ;
                                         if (ret > 0)
                                                locNm += "<strong><p style="+"\"color:"+assetColor+"\">"+bnch+" : "+"<span style="+"\"color:black\""+">"+ ret + "% </span> </p></strong>";
                                         else
                                                locNm += "<strong><p style="+"\"color:"+assetColor+"\">"+bnch+" : "+"<span style="+"\"color:red\""+">"+ ret + "% </span> </p></strong>";

                                         if (ret1 > 0)
                                                locNm += "<strong><p style="+"\"color:"+cmpassetColor+"\">"+cmpAsset+" : "+"<span style="+"\"color:black\""+">"+ ret1 + "% </span> </p></strong>";
                                         else
                                                locNm += "<strong><p style="+"\"color:"+cmpassetColor+"\">"+cmpAsset+" : "+"<span style="+"\"color:red\""+">"+ ret1 + "% </span> </p></strong>";
					 
					 return locNm;	
                        }
                }
                return "<strong><p style="+"\"color:red\""+">"+locNm+": Markets Closed</p></strong>";

	}

	function retHistBinData(asset, phase){
		locList =  Object.keys(histMaster);
		
		for(histCtr = 0; histCtr< locList.length ; histCtr++){
			if ( locList[histCtr].indexOf( asset+'-'+phase ) > -1){
				return histMaster[locList[histCtr]]; 
			}
		}

		return -1;
	}
	
	function adder(a ){	
		var store = 0;
		for(Ctr = 0; Ctr< a.length ; Ctr++){
			store = store + a[Ctr]['value']
		}
	return store;	
	}
	
	
	function initHIST(){
	locList =  Object.keys(histList);
	//make new list for HV and LV alone
	
	
	var _chg_ = [];
                
		for(histCtr = 0; histCtr< locList.length ; histCtr++){
                        valArr = histList[locList[histCtr]];
			
			for(valCtr =0; valCtr < valArr.length; valCtr++){
        			var singleObj = {};
				singleObj['name'] = bins[valCtr];
                        	singleObj['value'] = valArr[valCtr];
				_chg_.push(singleObj)	
			}
		   	histMaster[ locList[histCtr] ]=_chg_;	
		   _chg_ = [];	
                }

	}

	function initTS(){
		var phase = timeSeries[ 0 ].Phase;
   		var idx = timeSeries[ 0 ].idx_name;
   		var _per_chg_ = [];
   		var _per_chg_for_LC = [];
		var cumSum = 0.0;

   		for (tsCtr = 1; tsCtr < timeSeries.length; tsCtr++){
        		var singleObj = {};
			var storeDt = ( timeSeries[ tsCtr ].idx_dt );
			var storeChg = ( timeSeries[ tsCtr ].cumChg );
			cumSum = cumSum + storeChg;
        			if( (timeSeries[ tsCtr ].Phase != phase || timeSeries[ tsCtr ].idx_name != idx) && _per_chg_.length > 0 ){
                			timeSeriesDict[idx+'-'+phase] = _per_chg_;
					//console.log(_per_chg_);	
                			phase = timeSeries[ tsCtr ].Phase;
                			idx = timeSeries[ tsCtr ].idx_name;
                			_per_chg_ = [];
					cumSum = 0.0;	
       				 }	
					
        		singleObj['dt'] = storeDt;
        		singleObj['cumuChg'] = cumSum;
        		singleObj['daily'] = storeChg;
			singleObj['zero'] = 0.0;
        		_per_chg_.push(singleObj);
   		}
		//fr the lst pair combo simply insert because it will come out when the tsCtr index reaches length
		timeSeriesDict[idx+'-'+phase] = _per_chg_;

		cumSum = 0.0;
   		var idx = tsIdxList[0].idx_name;
   		for (tsCtr = 1; tsCtr < tsIdxList.length; tsCtr++){
        		var singleObj = {};
			var storeDt = ( tsIdxList[ tsCtr ].idx_dt );
			var storeChg = ( tsIdxList[ tsCtr ].cumChg );
			cumSum = cumSum + storeChg;
				//time series for the line chart bottom right
        			if( ( tsIdxList[ tsCtr ].idx_name != idx) && _per_chg_for_LC.length > 0 ){
						tSDict[idx] = _per_chg_for_LC;
                				idx = tsIdxList[ tsCtr ].idx_name;
						_per_chg_for_LC = [];
						cumSum = 0.0;
				}
        		singleObj['dt'] = storeDt;
        		singleObj['cumuChg'] = cumSum;
        		singleObj['daily'] = storeChg;
			_per_chg_for_LC.push(singleObj);
   		}
		tSDict[idx] = _per_chg_for_LC;

	console.log('in initTS '+Object.keys(timeSeriesDict));
                if(_BM_MF_FromDt_idx == -1 && _BM_MF_ToDt_idx == -1){
				if ( tSDict[bnch].length < tSDict[cmpAsset].length){
                                	_BM_MF_FromDt_idx = Math.round( tSDict[bnch].length*(0.5) );
                                	_BM_MF_ToDt_idx = tSDict[bnch].length - 1;
				}else{
                                	_BM_MF_FromDt_idx = Math.round( tSDict[cmpAsset].length*(0.5) );
                                	_BM_MF_ToDt_idx = tSDict[cmpAsset].length - 1;
				}
                }


	}



	function retRelevantData( phase, asset ){
		console.log('in retRelevantData '+ asset+'-'+phase);
		var key_list = Object.keys(timeSeriesDict);
		var key_ctr = 0;
		while (key_ctr < key_list.length){
			//ding this because there seems to be some extra harecters being returned by key list ..i think its comeing from the db
 			// need to find method to trim extra chars
			console.log(key_list[key_ctr]);
			if(key_list[key_ctr].indexOf(asset+'-'+phase) > -1) break;
			key_ctr++;
		}
	//console.log('in retRelevantData '+timeSeriesDict[key_list[key_ctr]]);
		return timeSeriesDict[key_list[key_ctr]]
	}

	function retPhaseReturns( phase, asset ){
		var key_list = Object.keys(timeSeriesDict);
		var key_ctr = 0;
		window.assetHVReturn = 0.0;
		window.cmpassetHVReturn = 0.0;
		window.assetLVReturn = 0.0;
		window.cmpassetLVReturn = 0.0;

		while (key_ctr < key_list.length){
			//ding this because there seems to be some extra harecters being returned by key list ..i think its comeing from the db
 			// need to find method to trim extra chars
			locTS = timeSeriesDict[key_list[key_ctr]];
			if ( phase == 'HV'){
				if( key_list[key_ctr].indexOf(asset+'-'+'FLAT') > -1 ) {
					//now fnd the relevant time series and find the last entry
					if ( asset == bnch){
						assetHVReturn += locTS[locTS.length-1].cumuChg;
						console.log('Phase - HV - asset '+key_list[key_ctr]+' '+locTS[locTS.length-1].cumuChg);
					}
					else if (asset == cmpAsset){
						cmpassetHVReturn += locTS[locTS.length-1].cumuChg;
						console.log('Phase - HV - asset '+key_list[key_ctr]+' '+locTS[locTS.length-1].cumuChg);
					}
				}
			}
			else if ( phase == 'LV'){
				if( key_list[key_ctr].indexOf(asset+'-'+'BULL') > -1 ){
					//now fnd the relevant time series and find the last entry
					if ( asset == bnch){
						assetLVReturn += locTS[locTS.length-1].cumuChg;
						console.log('Phase - LV - asset '+key_list[key_ctr]+' '+locTS[locTS.length-1].cumuChg);
					}
					else if (asset == cmpAsset){
						console.log('Phase - LV - asset '+key_list[key_ctr]+' '+locTS[locTS.length-1].cumuChg);
						cmpassetLVReturn += locTS[locTS.length-1].cumuChg;
					}
				} 
			}
			key_ctr++;
		}
	//now verage it out
		assetHVReturn = assetHVReturn/2;
		cmpassetHVReturn = cmpassetHVReturn/2;		
		assetLVReturn = assetLVReturn/2;
		cmpassetLVReturn = cmpassetLVReturn/2;		

		if ( phase == 'HV' && asset == bnch ) return assetHVReturn;
		if ( phase == 'HV' && asset != bnch ) return cmpassetHVReturn;
		if ( phase == 'LV' && asset == bnch ) return assetLVReturn;
		if ( phase == 'LV' && asset != bnch ) return cmpassetLVReturn;
	}

        
	
	function setBMDataBasedOnMF(_mf_name){
		dispBMName = retBMName(_mf_name);
		dispMFName = _mf_name;
		bm_Data_ = retBMData(_mf_name);
		
		window.current_MF_Data_ = retMFData (_mf_name);
		console.log();
		//init
		bm_Data_.forEach(function(d) {
					
					d.dt = new Date(d.dt);
					
					d.closing = +d.closing;
				  });
		current_MF_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					
					d.closing = +d.closing;
				  });
				  
		console.log("IN setBMDataBasedOnMF value of MF "+_mf_name+" and length "+ current_MF_Data_.length);
	}
	
	function _reScaleBM_MF_axes( area, phase, showLegend ){

		var margin = {top: 20, right: 30, bottom: 20, left: 30};
			if (current_MF_Data_.length == 0){	  
				  current_MF_Data_ = bm_Data_;
			}

			if( area == ".chart2" && currPhase == 'HV'){
				window.sliced_bm_Data_ = retRelevantData(HVPhases[0] , bnch);
				window.current_Data_ = retRelevantData(HVPhases[0], cmpAsset);
			} 
			else if( area == ".chart22" && currPhase == 'HV'){
				window.sliced_bm_Data_ = retRelevantData(HVPhases[1] , bnch);
				window.current_Data_ = retRelevantData(HVPhases[1], cmpAsset);
			} 
			else if( area == ".chart2" && currPhase == 'LV'){
				window.sliced_bm_Data_ = retRelevantData(LVPhases[0] , bnch);
				window.current_Data_ = retRelevantData(LVPhases[0], cmpAsset);
			} 
			else if( area == ".chart22" && currPhase == 'LV'){
				window.sliced_bm_Data_ = retRelevantData(LVPhases[1] , bnch);
				window.current_Data_ = retRelevantData(LVPhases[1], cmpAsset);
			} 
			
			sliced_bm_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					d.cumuChg = +d.cumuChg;
				  });
			
			current_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					d.cumuChg = +d.cumuChg;
				  });

			//store the data structures for recall in hovers
			var singleTon = {};
			singleTon['BM'] = sliced_bm_Data_;
			singleTon['ASS'] = current_Data_;
			storeAreaData[ [area] ] = singleTon;		
			
			var mindt = new Date(); var maxdt = new Date(); var minClose = 0; var maxClose = 0;
			// figure out the min and max shite
			if( d3.max(sliced_bm_Data_, function(d) { return d.cumuChg; }) > d3.max(current_Data_, function(d) { return d.cumuChg; }) )
				maxClose = d3.max(sliced_bm_Data_, function(d) { return d.cumuChg; });
			else
				maxClose = d3.max(current_Data_, function(d) { return d.cumuChg; });
				
			if( d3.min(sliced_bm_Data_, function(d) { return d.cumuChg; }) < d3.min(current_Data_, function(d) { return d.cumuChg; }) )
				minClose = d3.min(sliced_bm_Data_, function(d) { return d.cumuChg; });
			else
				minClose = d3.min(current_Data_, function(d) { return d.cumuChg; });
				
			if( d3.max(sliced_bm_Data_, function(d) { return d.dt; }) > d3.max(current_Data_, function(d) { return d.dt; }) )
				maxdt = d3.max(sliced_bm_Data_, function(d) { return new Date(d.dt); });
			else
				maxdt = d3.max(current_Data_, function(d) { return new Date(d.dt); });
				
			if( d3.min(sliced_bm_Data_, function(d) { return d.dt; }) < d3.min(current_Data_, function(d) { return d.dt; }) )
				mindt = d3.min(sliced_bm_Data_, function(d) { return new Date(d.dt); });
			else
				mindt = d3.min(current_Data_, function(d) { return new Date(d.dt); });
			//
			
			var xScaler = d3.time.scale()
			.range([0, LCCWidth]);

			var yScaler = d3.scale.linear()
			.range([LCCHeight , 0]);
			
			var xAxis = d3.svg.axis()
			.scale(xScaler)
			.orient("bottom")
			//.innerTickSize(-LCCHeight)
                        //.outerTickSize(0)
			.tickFormat(d3.time.format("%b"));

			var yAxis = d3.svg.axis()
			.scale(yScaler)
			.orient("left")
			//.tickValues([-1,-0.5, -0.25, 0,0.05 ,0.10, 0.25 ,0.5,1])
			.innerTickSize(-LCCWidth)
                        .outerTickSize(0)
			.tickFormat(d3.format("%"));


			var line = d3.svg.line()
						.x(function(d) { return xScaler((d.dt)); })
						.y(function(d) { return yScaler(d.cumuChg); });

			var line1 = d3.svg.line()
						.x(function(d) { return xScaler((d.dt)); })
						.y(function(d) { return yScaler(d.zero); });

			var svg = d3.select(area);
			
			//clear existing
			svg.selectAll("path")
			.remove();

			
			//svg.selectAll("text").remove();
			//rescale if necessary
			
			xScaler.domain([mindt, maxdt]);
			yScaler.domain([minClose, maxClose]);
			
			
			svg.select(".y.axis").transition().duration(500).ease("sin-in-out")  // https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
                    .call(yAxis); 
		    svg.select(".x.axis").transition().duration(500).ease("sin-in-out")  // https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
                    .call(xAxis); 	
		
			//add benchmark
		if( showLegend == 1){
			window.benchMarkPath =	svg.append("path")
			  .datum(sliced_bm_Data_)
			  .attr("class", "line")
			  .attr("d", line)
			  //.attr("data-legend", bnch)
			  .attr("stroke",assetColor)
			  .attr("transform", "translate("+margin.right+","+margin.top+")")

		}
		else{
			window.benchMarkPath =	svg.append("path")
			  .datum(sliced_bm_Data_)
			  .attr("class", "line")
			  .attr("d", line)
			  //.attr("data-legend", 'Returns - '+phase)
			  .attr("stroke",assetColor)
			  .attr("transform", "translate("+margin.right+","+margin.top+")")
		}
		//zero line
	  
			//if the user hath selected some MF  
			if( showLegend == 1){
				window.MFPath = svg.append("path")
				  .datum(current_Data_)
				  .attr("class", "line")
				  .attr("d", line)
				  //.attr("data-legend", cmpAsset)
				  .attr("stroke",cmpassetColor)
			  .attr("transform", "translate("+margin.right+","+margin.top+")")
			} else {
				window.MFPath = svg.append("path")
				  .datum(current_Data_)
				  .attr("class", "line")
				  .attr("d", line)
				  .attr("stroke",cmpassetColor)
			  .attr("transform", "translate("+margin.right+","+margin.top+")")
			
			}		  
			

    }
	

	function genHist( area, phase , container ){

		var margin = {top: 5, right: 5, bottom: 20, left: 5};
		
		
		if(barWidth == 0){	
               		width = parseFloat ($("#MFHist").css("width"))/2 - 2*margin.left - 2*margin.right,
               		height = parseFloat ($("#MFHist").css("height")) - margin.top - margin.bottom;
			barWidth = width;
		}else{
			height = parseFloat ($("#MFHist").css("height")) - margin.top - margin.bottom;
			width = barWidth;
		}
	

//temp change - replace 2 barcharts with just 1 for the entire HV phase

		if (currPhase == 'HV'){	
			var bnchData = retHistBinData( bnch, HVPhases[0]);
			var bnchData1 = retHistBinData( bnch, HVPhases[1]);
			var assData = retHistBinData( cmpAsset , HVPhases[0]);
			var assData1 = retHistBinData( cmpAsset , HVPhases[1]);
		}else{
			var bnchData = retHistBinData( bnch, LVPhases[0]);
			var bnchData1 = retHistBinData( bnch, LVPhases[1]);
			var assData = retHistBinData( cmpAsset , LVPhases[0]);
			var assData1 = retHistBinData( cmpAsset , LVPhases[1]);
		}

		for (test=0; test < bnchData.length; test++){
			bnchData[test].value += bnchData1[test].value;
			assData[test].value += assData1[test].value;
			console.log('DOGGIE '+test+' '+bnchData[test].value);
		}

                width = parseFloat ($("#MFHist").css("width")) - 2*margin.left - 2*margin.right;

		var xHist = d3.scale.ordinal()
			.rangeRoundBands([width,0], 0.1);
		var yHist = d3.scale.linear()
			.range([height,0]);

		var xAxis = d3.svg.axis()
			.scale(xHist)
			.orient("bottom")
			.tickValues([-0.12,-0.06,-0.02,0, 0.02, 0.04, 0.08, 0.13])
			.tickFormat(d3.format("%"));


		var yAxis = d3.svg.axis()
			.scale(yHist)
			.orient("left");
//temp cange
		var normbnch = adder(bnchData);
		var normass = adder(assData);

		window.barChart22 = d3.select("body")
                                .append("div-tool")  // declare the tooltip div
                                .attr("class", "d3-tip")              // apply the 'tooltip' class
                                .style("opacity", 0);



		console.log('ass '+normbnch+'-'+normass);
		console.log('asshole '+ IQRList[bnch+'-'+phase+'\r']);

		if (phase == HVPhases[0] || phase == HVPhases[1]){
                                        HVBMIQR = HVBMIQR + IQRList[bnch+'-'+phase+'\r'];
                                        HVAssetIQR = HVAssetIQR + IQRList[cmpAsset+'-'+phase+'\r'];
                }
                else if (phase == LVPhases[0] || phase == LVPhases[1] ){
                                        LVBMIQR = LVBMIQR + IQRList[bnch+'-'+phase+'\r'];
                                        LVAssetIQR = LVAssetIQR + IQRList[cmpAsset+'-'+phase+'\r']; 
                }


		xHist.domain(bnchData.map(function(d) { return d.name; }));
		if( d3.max( bnchData , function(d) { return d.value; }) > d3.max(assData , function(d) { return d.value; }) )
			yHist.domain([0, d3.max(bnchData , function(d) { return d.value/normbnch; })]);
		else
			yHist.domain([0, d3.max(assData , function(d) { return d.value/normass; })]);

		var chart = d3.select(area)
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		chart.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate(0," + height + ")")
			  .call(xAxis);


		chart.selectAll(area)
			  .data(bnchData)
			.enter().append("rect")
			  .attr("class", "bar")
			  .attr("x", function(d) { return xHist(d.name)+2; })
			  .attr("y", function(d) { return yHist(d.value/normbnch); })
			  .attr("height", function(d) { return height - yHist(d.value/normbnch); })
			  .attr("width", xHist.rangeBand()-5)
			  .style("fill", assetColor);	

		chart.selectAll(area)
			  .data(assData)
			.enter().append("rect")
			  .attr("class", "bar1")
			  .attr("x", function(d) { return xHist(d.name); })
			  .attr("y", function(d) { return yHist(d.value/normass); })
			  .attr("height", function(d) { return height - yHist(d.value/normass); })
			  .attr("width", xHist.rangeBand())
			  .style("fill", cmpassetColor);	
			  //.attr("data-legend", "Volatility - "+phase)

                d3.select(area)
                        .on("mouseover", function() {

                          console.log('mouseover bugs');

                        })
                        .on("mousemove", function() {
                          var xCoOrd = d3.mouse(this)[0];
                          var yCoOrd = d3.mouse(this)[1];
			  var normbnch = adder(bnchData);
                          var normass = adder(assData);	
			  var bnchDist = 0.0;
			  var cmpDist = 0.0;
			  var range = '';	
	
			  offsetBinX = 0.0;	
			  offsetBinY = 0.0;	

			  console.log(' vik '+event.pageX+' '+event.pageY+' '+width);	
			  // user x and y co ords for finding offset
				//first hist from top left
				offsetBinX = margin.left+width/2;	
				offsetBinY = parseFloat( $("#upperLCContainer").css("height")) + parseFloat( $("#upperHdr").css("height")) + parseFloat( $("#upperLegend").css("height"));	

			  flg = bnchData[0];	
			  for (cr = 0; cr < bnchData.length ; cr++){
				//console.log('FREAK '+cr+' '+xHist( bnchData[cr].name )+' '+xCoOrd+' '+xHist( flg.name ) );
			  	if ( (xHist( bnchData[cr].name ) - xHist.rangeBand()/2 ) < (xCoOrd) && (xCoOrd) < (xHist( bnchData[cr].name ) + xHist.rangeBand()/2 )  )
				{
					console.log("Clicked on " + bnchData[cr+1].name +'- '+ bnchData[cr].name+' '+(parseFloat(bnchData[cr].value)/normbnch)*100+' '+(parseFloat(assData[cr].value)/normbnch)*100);
					bnchDist = Math.round((parseFloat(bnchData[cr+1].value)/normbnch)*100);
					cmpDist = Math.round( (parseFloat(assData[cr+1].value)/normbnch)*100);
					range = parseFloat( bnchData[cr+1].name )*100+' To '+ parseFloat( bnchData[cr].name )*100+' %';
					break;
				}
				flg = bnchData[cr];
			  }

                        xOff = offsetBinX;
                        yOff = offsetBinY;
                        // no idea why this is needed defaultOffset i mean ..
                        defaultOffset = 20;
                        hoverWidth = parseFloat($('.d3-tip').css("width"));
                        hoverHeight = parseFloat($('.d3-tip').css("height"));

                        {
                                xOff += hoverWidth - 4*margin.left ;
                                yOff += 3*hoverHeight;
                        }


                        tipLineChart22.transition().duration(200)
                        .style("opacity", 0.7);
                        var formHtml = '';
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+">"+" Daily % Chg Distribution </p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:steelblue; font-size:20px;\""+">"+range+ "</p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:"+assetColor+"\">"+bnch+" : "+ bnchDist +"%</p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:"+cmpassetColor+"\">"+cmpAsset+" : "+ cmpDist +"%</p></strong>";
			

                        tipLineChart22 .html( formHtml)
                                .style("left", (xOff ) + "px")
                                .style("top", (yOff) + "px");
	


			  //console.log( "MUDKA "+xCoOrd+' '+' '+yCoOrd+' '+ width1+' ' + width );
			})
			  .on("mouseout", function() {
				tipLineChart22.transition().duration(200)
                        	.style("opacity", 0.01);
                        });

/*
		chart.append("g")
			.attr("class","legend")
			.attr("transform","translate(0,25)")
			.style("font-size","15px")
			.attr("data-style-padding",10)
			.call(d3.legend);	
*/
		//});

		function type(d) {
		  d.value = +d.value; // coerce to number
		  return d;
		}
	}
</script>


	<div id = "HDR1">
               <p id="HeaderButton">
		 <button class="btn btn-7 btn-7a ">Fund Of Funds</button>
               	 <button class="btn btn-7 btn-7a ">Fund House</button>
		 <button class="btn btn-7 btn-7a ">Fund Manager</button>
               	 <button class="btn btn-7 btn-7a ">Synthetic Portfolios</button>
	       </p>
	</div>


	

	<div id="loader-wrapper">
    		<div id="loader"></div>
	</div>

<!-- begin container for upper shite -->
<div id="upperHouse">
	<div id = "upperHdr">
	   <div id = "TitleCont">	
		<h2 id="GyanHdr">Risk Vs Returns <img src="{% static 'jquery-ui-1.11.4.custom/QS.png' %}" width="30" height="30" alt="" id="QM" data-modal="modal-1" class="md-trigger"></h2>
	   </div>
	   <div id = "phaseButton">	
			<button class="md-close" id="lvButton" onclick="toggleSwitch('LV');" >Switch To Low Volatility</button>
			<button class="md-close" id="hvButton"  onclick="toggleSwitch('HV');">High Volatility</button>

			<script>
				initGlobalSetBM();	
				//hex to rgb from SO http://stackoverflow.com/questions/1740700/how-to-get-hex-color-value-rather-than-rgb-value
				var hexDigits = new Array
        					("0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f");
				function rgb2hex(rgb) {
 					rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
 					return "#" + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]);
				}

				function hex(x) {
  					return isNaN(x) ? "00" : hexDigits[(x - x % 16) / 16] + hexDigits[x % 16];
 				}

				function toggleSwitch( comingFrom ){
					if( comingFrom == 'HV' && rgb2hex( $("#hvButton").css("background-color") ) != '#7b9095' ){
					}
					else if( comingFrom == 'HV' && rgb2hex( $("#hvButton").css("background-color") ) == '#7b9095' ){
						$("#hvButton").html('High Volatility');
						$("#lvButton").html('Switch To Low Volatility');
						$("#hvButton").css("background","#A8CD1B" );
						$("#lvButton").css("background","#7b9095" );
						currPhase = 'HV';
						//first arg is supposed to be ajax return, but given we are calling w/o that dont pass arg
						//0 doubly indicates that
						refreshWithLatest(0);
					}
					else if( comingFrom == 'LV' && rgb2hex ($("#lvButton").css("background-color")) != '#7b9095' ){
					}
					else if( comingFrom == 'LV' && rgb2hex ( $("#lvButton").css("background-color") ) == '#7b9095' ){
						$("#lvButton").html('Low Volatility');
						$("#hvButton").html('Switch To High Volatility');
						$("#lvButton").css("background","#A8CD1B" );
						$("#hvButton").css("background","#7b9095" );
						currPhase = 'LV';
						refreshWithLatest(0);
					}
				//TEST --------------
				}
			</script>
			
	   </div>
<!--			
	<div id= "legendado">
		<svg class="leg" id="OK"></svg>	
		<script>
			paintLegend();

		function paintLegend() {
			var rad = 10;
 			var margin = {top: 5, right: 5, bottom: 5, left: 5},
                	width = parseFloat( $("#legendado").css("width") ) - margin.left - margin.right,
                	height = parseFloat( $("#legendado").css("height") ) - margin.top - margin.bottom;

			d3.select(".leg").selectAll("*").remove();			

			var svg = d3.select(".leg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                        .append("g");
		

			svg.append("circle")
                                .attr({ r: rad, fill: '#7D1935' })
				.attr("cx", margin.left+rad )
				.attr("cy", 2*margin.top+rad );
//add names of assets
			svg.append("text")
				.attr("x", 2*margin.left+2*rad )
                                .attr("y", 2*margin.top+2*rad-2 )
				.text(bnch)
				.attr("font-family", "'Open Sans', arial")
                 		.attr("font-size", "20px")
                 		.attr("fill", assetColor);
		
			svg.append("circle")
                                .attr({ r: rad, fill: 'steelblue' })
				.attr("cx", margin.left+rad )
				.attr("cy", 3*margin.top+3*rad );

			svg.append("text")
				.attr("x", 2*margin.left+2*rad )
                                .attr("y", 2*margin.top+4*rad+2 )
				.text(cmpAsset)
				.attr("font-family", "'Open Sans', arial")
                 		.attr("font-size", "20px")
                 		.attr("fill", cmpassetColor);

		}

		</script>
	</div> 
-->
	</div>
	
<!-- the below div is going to be used for the legend container -->
	<div id="upperLegend">
		<div id="asset1">
		    <svg class="bnchLegend" id="OK"></svg>	
			<script>
				$("#asset1").css("background", assetColor);	
				//call for first screen load
				paintbnch();				

				function paintbnch(){
 					var margin = {top: 5, right: 5, bottom: 5, left: 5},
                			width = parseFloat( $("#asset1").css("width") ) - margin.left - margin.right,
                			height = parseFloat( $("#asset1").css("height") ) - margin.top - margin.bottom;
				
					d3.select(".bnchLegend").selectAll("*").remove();			

					var svg = d3.select(".bnchLegend")
                        			.attr("width", width + margin.left + margin.right)
                        			.attr("height", height + margin.top + margin.bottom)
                        			.append("g");
		
//add names of asset			
					var ret = '';
					var par = parseFloat (retPhaseReturns( currPhase, bnch ) );
					if(  par < 0){
						ret = '  ( '+Math.round( par*100)+' )%';
					}
					else
						ret = '  '+Math.round( par*100)+' %';
						
					svg.append("text")
						.attr("x", 2*margin.left )
                                		.attr("y", 4*margin.top )
						.text( bnch+ret )
						.attr("font-family", "'Open Sans', arial")
                 				//.attr("font-size", "20px")
                 				.attr("font-size", "15px")
                 				.style("fill", "white")
                 				.style("opacity", 1);
					
					svg.append("text")
						.attr("x", 2*margin.left )
                                		.attr("y", 7*margin.top )
						.text( 'Average Returns for Phase ')
						.attr("font-family", "'Open Sans', arial")
                 				//.attr("font-size", "15px")
                 				.attr("font-size", "12px")
                 				.style("fill", "white")
                 				.style("opacity", 1);
				}
			</script>
		</div>
		<div id="asset2">
		    <svg class="cmpLegend" id="OK"></svg>	
			<script>
				$("#asset2").css("background", cmpassetColor);	
				paintcmp();
				function paintcmp(){
 					var margin = {top: 5, right: 5, bottom: 5, left: 5},
                			width = parseFloat( $("#asset2").css("width") ) - margin.left - margin.right,
                			height = parseFloat( $("#asset2").css("height") ) - margin.top - margin.bottom;

					d3.select(".cmpLegend").selectAll("*").remove();			

					var svg = d3.select(".cmpLegend")
                        			.attr("width", width + margin.left + margin.right)
                        			.attr("height", height + margin.top + margin.bottom)
                        			.append("g");
		
//add names of assets
					var ret = '';
					var par = parseFloat (retPhaseReturns( currPhase, cmpAsset ) );
					if(  par < 0){
						ret = '  ( '+Math.round( par*100)+' )%';
					}
					else
						ret = '  '+Math.round( par*100)+' %';

					svg.append("text")
						.attr("x", 2*margin.left )
                                		.attr("y", 4*margin.top )
						.text( cmpAsset+ret )
						.attr("font-family", "'Open Sans', arial")
                 				//.attr("font-size", "20px")
                 				.attr("font-size", "16px")
                 				.style("fill", "white")
                 				.style("opacity", 1);
					
					svg.append("text")
						.attr("x", 2*margin.left )
                                		.attr("y", 7*margin.top )
						.text( 'Average Returns for Phase' )
						.attr("font-family", "'Open Sans', arial")
                 				//.attr("font-size", "15px")
                 				.attr("font-size", "12px")
                 				.style("fill", "white")
                 				.style("opacity", 1);
				}
			</script>
		</div>
	<div id = "BMList">	
		<label for="search"></label>
		<input id="search" value="Change Benchmark">
	</div>
	</div>
	<div class="md-modal md-effect-1" id="modal-1">
			<div class="md-content">
				<h3>Risk Vs Returns</h3>
				<div>
					<ul>
						<li>This page contains data from the last couple high and low volatile time periods and intends to compare the behavior of the chosen asset against a benchmark (NIFTY) on 2 major fronts- risk and returns. The time periods have been chosen by us based on our studies of the last 8 years of market data and can be ascertained by HOVERING over the charts.</li>
						<li>Returns: The top 2 line charts compare the return charecteristics of the 2 assets during volatile periods. </li>
						<li>Risk: The bottom bar chart compare the risk charecteristics of the 2 assets during volatile periods. This is done by plotting the frequency of daily returns.Further details on the nature of risk is provided in the header for the bar chart below.</li>
						<li>So while choosing an asset please bear in mind that the returns should always be looked at from the perspective of risk. Based on market conditions a riskier asset can give you better / poorer returns. Look out for the textual commentary, on every screen.</li>
					</ul>
					<button class="md-close">Close me!</button>
				</div>
			</div>
	</div>	
	<div class="md-overlay"></div> <!-- the overlay element -->

	<div id = "upperLCContainer">
	<div id = "MFvsBM">
	<svg class="chart2" id="OK"></svg>
	<script>

		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width2 = parseFloat( $("#upperLCContainer").css("width") )/2 - 2*margin.left - 2*margin.right,
                height2 = parseFloat( $("#upperLCContainer").css("height") ) - margin.top - margin.bottom;

		window.offset2 =  2*margin.left; 
		window.LCCWidth = width2;
		window.LCCHeight = height2;

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler2 = d3.time.scale()
			.range([0, width2]);

		var yScaler2 = d3.scale.linear()
			.range([height2, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler2)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler2)
			.orient("left");

		var svg = d3.select(".chart2")
			.attr("width", width2 + margin.left + margin.right)
			.attr("height", height2 + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
		 //add hover line
                var hoverLineGroup = svg.append("g")
                                  .attr("class", "hover-line");

                window.hoverLine2 = hoverLineGroup
                                .append("line")
                                .attr("x1", 0).attr("x2", 0)
                                .attr("y1", 0).attr("y2", height2)
                                .style("opacity", 0.1);

                  // Hover line.



                d3.select(".chart2")
			.on("mouseover", function() {

                          console.log('mouseover bugs');

                        })
			.on("mousemove", function() {
                          var xCoOrd = d3.mouse(this)[0];
                          var yCoOrd = d3.mouse(this)[1];

			if ( xCoOrd >= (width2 + margin.left +2 )) return 1;
			if ( xCoOrd < margin.left) return 1;

			console.log('DEUCHE '+xCoOrd+' '+yCoOrd);
		  	locData = storeAreaData['.chart2'];
		  	xScaler2.domain(d3.extent( locData.BM  , function(d) { return d.dt; }));
			
                        xOff = offset2;
                        yOff = 0.0;
                        // no idea why this is needed defaultOffset i mean ..
                        defaultOffset = 20;
                        hoverWidth = parseFloat($('.d3-tip').css("width"));
                        hoverHeight = parseFloat($('.d3-tip').css("height"));

                        if ( (xCoOrd < width2/2) )
                        {
                                xOff = xOff + width2 - hoverWidth + 2*margin.left;
				yOff = 2*hoverHeight;
                        }
			else if ( (xCoOrd >= width2/2) )
                        {
                                xOff = xOff + margin.left + margin.right;// + hoverWidth;
				yOff = 2*hoverHeight;
                        }


			hoverLine2.style("opacity", 1);
                        //circleBenchMark22.attr("opacity", 0.4);
                        tipLineChart22.transition().duration(200)
			.style("opacity", 0.7);
                        if ( xCoOrd >= (width2 + margin.left  ))
                                hoverLine2.attr("x1", width2  ).attr("x2", width2 ).style("opacity", 0.5);
                        else
                                hoverLine2.attr("x1", xCoOrd - marOffsetX ).attr("x2", xCoOrd - marOffsetX ).style("opacity", 0.5);
                        locDt = new Date ( xScaler2.invert(xCoOrd - marOffsetX) );
                        var formHtml = '';
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+">" +locDt.getDate()+" "+MnthRev[(locDt.getMonth())+1]+","+locDt.getFullYear() +" </p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:black\""+"> (Cumulative Returns) </p></strong>";
                        formHtml += retDailyData( locDt ,".chart2" );


                        tipLineChart22 .html( formHtml)
                                .style("left", (xOff ) + "px")
                                .style("top", (yOff) + "px");

                        // Use event.pageX / event.pageY here

                        })  .on("mouseout", function() {
                                console.log('bill');
                                tipLineChart22.transition().duration(200)
				.style("opacity",0);
                                hoverLine2.style("opacity",0);
                  });
                                  // Hover line.

		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate(0," + height2 + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")


		//call the final rendering
		_reScaleBM_MF_axes( ".chart2", HVPhases[0], 1); 	
		
		
	</script>
		
	
	</div>



	<div id = "MFvsBM">
	<svg class="chart22" id="OK"></svg>
	<script>	
		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width22 = parseFloat( $("#upperLCContainer").css("width") )/2 - 2*margin.left - 2*margin.right,
                height22 = parseFloat( $("#upperLCContainer").css("height") ) - margin.top - margin.bottom;
		//width = 700 , height = 500 ;
		window.offset22 = parseFloat( $("#upperLCContainer").css("width") )/2 + 2*margin.left; 

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler22 = d3.time.scale()
			.range([0, width22]);

		var yScaler22 = d3.scale.linear()
			.range([height22, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler22)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler22)
			.orient("left");

		var svg = d3.select(".chart22")
			.attr("width", width22 + margin.left + margin.right)
			.attr("height", height22 + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
		 //add hover line

                  // Hover line.
                var hoverLineGroup = svg.append("g")
                                  .attr("class", "hover-line");

                window.hoverLine22 = hoverLineGroup
                                .append("line")
                                .attr("x1", 0).attr("x2", 0)
                                .attr("y1", 0).attr("y2", height22)
				.style("opacity", 0.1);
                        // Hide hover line by default.


                window.tipLineChart22 = d3.select("body")
                //window.tipLineChart = svg 
                                .append("div-tool")  // declare the tooltip div
                                .attr("class", "d3-tip")              // apply the 'tooltip' class
                                .style("opacity", 0);


               circleBenchMark22 = svg.append("circle")
                                .attr("opacity", 0.00001)
                                .attr({ r: dispCircleRadius, fill: 'red' });



                d3.select(".chart22")
			.on("mouseover", function() {

                          console.log('mouseover bugs');

                        })
			.on("mousemove", function() {
                          var xCoOrd = d3.mouse(this)[0];
                          var yCoOrd = d3.mouse(this)[1];

			if ( xCoOrd >= (width22 + margin.left +2 )) return 1;
			if ( xCoOrd < margin.left) return 1;

			console.log('DEUCHE '+xCoOrd+' '+yCoOrd);
		  	locData = storeAreaData['.chart22'];
		  	xScaler22.domain(d3.extent( locData.BM  , function(d) { return d.dt; }));
			
                        xOff = offset22;
                        yOff = 0.0;
                        // no idea why this is needed defaultOffset i mean ..
                        defaultOffset = 20;
                        hoverWidth = parseFloat($('.d3-tip').css("width"));
                        hoverHeight = parseFloat($('.d3-tip').css("height"));

                        if ( (xCoOrd < width22/2) )
                        {
                                xOff = xOff + width22 - hoverWidth + 2*margin.left;
				yOff = 2*hoverHeight;
                        }
			else if ( (xCoOrd >= width22/2) )
                        {
                                xOff = xOff + margin.left + margin.right;// + hoverWidth;
				yOff = 2*hoverHeight;
                        }


			hoverLine22.style("opacity", 1);
                        //circleBenchMark22.attr("opacity", 0.4);
                        tipLineChart22.transition().duration(200)
			.style("opacity", 0.7);
                        if ( xCoOrd >= (width22 + margin.left  ))
                                hoverLine22.attr("x1", width22  ).attr("x2", width22 ).style("opacity", 0.5);
                        else
                                hoverLine22.attr("x1", xCoOrd - marOffsetX ).attr("x2", xCoOrd - marOffsetX ).style("opacity", 0.5);
                        locDt = new Date ( xScaler22.invert(xCoOrd - marOffsetX) );
                        var formHtml = '';
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+">" +locDt.getDate()+" "+MnthRev[(locDt.getMonth())+1]+","+locDt.getFullYear() +" </p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:black\""+"> (Cumulative Returns) </p></strong>";
                        formHtml += retDailyData( locDt ,".chart22" );


                        tipLineChart22 .html( formHtml)
                                .style("left", (xOff ) + "px")
                                .style("top", (yOff) + "px");

                        // Use event.pageX / event.pageY here

                            var pathLength = benchMarkPath.node().getTotalLength();
                                //console.log("bm length " + pathLength );
                                //since our hover line has an offset from the xAxis our search
                                //needs to begin from there rather than plain xCoord
                                var x = xCoOrd - margin.left;
                                var beginning = x,
                                        end = pathLength,
                                        target;
                                while (true) {
                                        target = Math.floor((beginning + end) / 2);
                                        posBM = benchMarkPath.node().getPointAtLength(target);
                                        if ((target === end || target === beginning) && posBM.x !== x) {
                                                break;
                                        }
                                        if (posBM.x > x) end = target;
                                        else if (posBM.x < x) beginning = target;
                                        else break; //position found
                                }

                                //circleBenchMark22.attr("opacity", 0.5)
                                //        .attr("cx", posBM.x )
                                //        .attr("cy", posBM.y)

                        })  .on("mouseout", function() {
                                console.log('bill');
                                circleBenchMark22.attr("opacity", 0.001);
                                tipLineChart22.transition().duration(200)
				.style("opacity",0);
                                hoverLine22.style("opacity",0);
                  });
                                  // Hover line.

			
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate(0," + height22 + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")
			  .style("text-anchor", "end")
			  .text("Cumulative Change (%)");
		//call the final rendering
		
		_reScaleBM_MF_axes( ".chart22", HVPhases[1], 0); 	
		
		
	</script>
	</div>

	</div>



<!-- end container for upper shite -->
</div>

<div id = "ListTextContainer">
	
	<div id = "MFvsBMText">
	<div id = "info1">
			<p id="DetailedHeader1" > PlaceHolder </p>
	</div>
	<section id="grid" class="grid clearfix">
<!--		<a href="#" data-path-hover="m 180,34.57627 -180,0 L 0,0 180,0 z"> -->
		
<!--		  <svg viewBox="0 0 0 320" preserveAspectRatio="none"><path d="M 180,300 0,300 0,0 180,0 z"/></svg> -->
			<figcaption>
				<h2 id="Header1">PlaceHolder</h2>
				<p id="Header1-Para">PlaceHolder</p>
                 	</figcaption>
		
		</a>	
	</section>
    </div>

</div>

<div id = "lowerHouse">

	<div id = "upperHistContainer">
	   <div id = "HistTitleCont">	
		<h2 id="HistHdr">Returns Distribution <img src="{% static 'jquery-ui-1.11.4.custom/QS.png' %}" width="30" height="30" alt="" id="QM" data-modal="modal-2" class="md-trigger"></h2>
	   </div>
	   <div id = "sliderAndDt">
	        <div id="dragslider-range" class="vik"></div>
		<div id ="TopCont">
                                <input type="text" readOnly='true' id="FromDt"><input type="text" readOnly='true' id="ToDt" >
		</div>

		<script>
                	window.DragSliderWidth = parseFloat( $("#dragslider-range").css("width") );
                	var margin = {top: 20, right: 30, bottom: 20, left: 30};
                	DragSliderWidth = DragSliderWidth - margin.left - margin.right;
                	//now set the width for dragslider
		</script>

	   </div>		
	
		<div id = "lowerCrap">	
	
			<div id = "MFHist">
			<svg class="histFlat1"></svg>
        		<script>
				genHist(".histFlat1", "HV", 0);
			</script>	
			</div>
		
			<div id = "whlsLineChart">
			<svg class="lastLine"></svg>
				<script src="{% static 'jquery-ui-1.11.4.custom/GraphWithBling.js' %}"></script>
				<script>
					// signature -- _drawBM_MF_axes ("#whlsLineChart", ".lastLine", tSDict, bnch , cmpAsset , slider, fromDt, toDt );
					_drawBM_MF_axes ("#whlsLineChart", ".lastLine", tSDict, bnch , cmpAsset, "#dragslider-range", "#FromDt", "#ToDt" );
				</script>
			</div>
		</div>

	</div> <!-- this end is for upperHist -->
<!-- overlay for histogram explanation -->
	<div class="md-modal md-effect-1" id="modal-2">
			<div class="md-content">
				<h3>Returns Distribution / Volatility</h3>
				<div>
					<ul>
						<li>This chart is called a histogram. It plots the frequency of distribution of daily returns. Why is this needed? And how is it connected to Risk ?</li>
						<li>Given that the asset price changes daily, we measure the change in %. So if the price moved from 10 to 11 and back to 10, the % changes would read 10% (from 10-11) and (-9%) (from 11-10). So if we take a time frame of, say an year and for all the days, measure this change, categorize into buckets(0 to 1%, -1% to +1% and so on) and then count the frequency, it tells us how much the prices fluctuated!</li>
						<li>But how is this related to risk? simple - the more prices have jumped around, the more chances it has to land in different buckets. With us so far? Good .. Now when will prices jump around ? when there's more uncertainty and voila, that is one of the most significant measures of risk. Hence in a bearish market, when the uncertainity is HIGH, the markets tend to be more volatile.</li>
						<li>Its essential to see for yourself, how different assets do in volatile phases to ascertain whether they are good / safe bets when we are expecting volatility in the markets</li>
					</ul>
					<button class="md-close">Got it! Close!</button>
				</div>
			</div>
	</div>	

	<div class="md-overlay"> </div> <!-- the overlay element -->
	<script src="{% static 'jquery-ui-1.11.4.custom/tymp-modal1.js' %}"></script>
	<script src="{% static 'jquery-ui-1.11.4.custom/tymp-modal2.js' %}"></script>

</div>


<!-- lower shite -->
<!--
<div id = "lowerHouse">

	<div id = "lowerLCContainer">

	<div id = "MFvsBM1">
	<svg class="chart23" id="OK"></svg>
	<script>	
		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width23 = parseFloat( $("#upperLCContainer").css("width") )/2 - 2*margin.left - 2*margin.right,
                height23 = parseFloat( $("#upperLCContainer").css("height") ) - margin.top - margin.bottom;
		//width = 700 , height = 500 ;
		window.offset23 =  screen.width - parseFloat( $("#upperLCContainer").css("width") ) - margin.left; 
		window.offset23Y =  parseFloat( $("#upperHouse").css("height") ) + margin.top*2 ; 

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler23 = d3.time.scale()
			.range([0, width23]);

		var yScaler23 = d3.scale.linear()
			.range([height23, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler23)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler23)
			.orient("left");

		var svg = d3.select(".chart23")
			.attr("width", width23 + margin.left + margin.right)
			.attr("height", height23 + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
		 //add hover line
                var hoverLineGroup = svg.append("g")
                                  .attr("class", "hover-line");

                window.hoverLine23 = hoverLineGroup
                                .append("line")
                                .attr("x1", 0).attr("x2", 0)
                                .attr("y1", 0).attr("y2", height23)
                                .style("opacity", 0.1);

                  // Hover line.



                d3.select(".chart23")
			.on("mouseover", function() {

                          console.log('mouseover bugs');

                        })
			.on("mousemove", function() {
                          var xCoOrd = d3.mouse(this)[0];
                          var yCoOrd = d3.mouse(this)[1];

			if ( xCoOrd >= (width23 + margin.left +2 )) return 1;
			if ( xCoOrd < margin.left) return 1;

			console.log('DEUCHE '+xCoOrd+' '+yCoOrd);
		  	locData = storeAreaData['.chart23'];
		  	xScaler23.domain(d3.extent( locData.BM  , function(d) { return d.dt; }));
			
                        xOff = offset23;
                        yOff = offset23Y;
                        // no idea why this is needed defaultOffset i mean ..
                        defaultOffset = 20;
                        hoverWidth = parseFloat($('.d3-tip').css("width"));
                        hoverHeight = parseFloat($('.d3-tip').css("height"));

                        if ( (xCoOrd < width23/2) )
                        {
                                xOff = xOff + width23 - hoverWidth + 2*margin.left;
				yOff += 2*hoverHeight;
                        }
			else if ( (xCoOrd >= width23/2) )
                        {
                                xOff = xOff + margin.left + margin.right;// + hoverWidth;
				yOff += 2*hoverHeight;
                        }


			hoverLine23.style("opacity", 1);
                        //circleBenchMark22.attr("opacity", 0.4);
                        tipLineChart22.transition().duration(200)
			.style("opacity", 0.7);
                        if ( xCoOrd >= (width23 + margin.left  ))
                                hoverLine23.attr("x1", width23  ).attr("x2", width23 ).style("opacity", 0.5);
                        else
                                hoverLine23.attr("x1", xCoOrd - marOffsetX ).attr("x2", xCoOrd - marOffsetX ).style("opacity", 0.5);
                        locDt = new Date ( xScaler23.invert(xCoOrd - marOffsetX) );
                        var formHtml = '';
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+">" +locDt.getDate()+" "+MnthRev[(locDt.getMonth())+1]+","+locDt.getFullYear() +" </p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:black\""+"> (Cumulative Returns) </p></strong>";
                        formHtml += retDailyData( locDt ,".chart23" );


                        tipLineChart22 .html( formHtml)
                                .style("left", (xOff ) + "px")
                                .style("top", (yOff) + "px");

                        // Use event.pageX / event.pageY here

                        })  .on("mouseout", function() {
                                console.log('bill');
                                tipLineChart22.transition().duration(200)
				.style("opacity",0);
                                hoverLine23.style("opacity",0);
                  });
                                  // Hover line.

			
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate(0," + height23 + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")



		//call the final rendering
		
		_reScaleBM_MF_axes( ".chart23" , "BULL2", 1); 	
		
		
	</script>
	</div>	

	<div id = "MFvsBM1">
	
	<svg class="chart24" id="OK"></svg>
	<script>	
		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width24 = parseFloat( $("#upperLCContainer").css("width") )/2 - 2*margin.left - 2*margin.right,
                height24 = parseFloat( $("#upperLCContainer").css("height") ) - margin.top - margin.bottom;
		//width = 700 , height = 500 ;
		window.offset24 =  screen.width - (parseFloat( $("#upperLCContainer").css("width") )/2) - margin.left; 
		window.offset24Y =  parseFloat( $("#upperHouse").css("height") ) + margin.top*2 ; 

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler24 = d3.time.scale()
			.range([0, width24]);

		var yScaler24 = d3.scale.linear()
			.range([height24, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler24)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler24)
			.orient("left");

		var svg = d3.select(".chart24")
			.attr("width", width24 + margin.left + margin.right)
			.attr("height", height24 + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
		 //add hover line
                var hoverLineGroup = svg.append("g")
                                  .attr("class", "hover-line");

                window.hoverLine24 = hoverLineGroup
                                .append("line")
                                .attr("x1", 0).attr("x2", 0)
                                .attr("y1", 0).attr("y2", height24)
                                .style("opacity", 0.1);

                  // Hover line.



                d3.select(".chart24")
			.on("mouseover", function() {

                          console.log('mouseover bugs');

                        })
			.on("mousemove", function() {
                          var xCoOrd = d3.mouse(this)[0];
                          var yCoOrd = d3.mouse(this)[1];

			if ( xCoOrd >= (width24 + margin.left +2 )) return 1;
			if ( xCoOrd < margin.left) return 1;

			console.log('DEUCHE '+xCoOrd+' '+yCoOrd);
		  	locData = storeAreaData['.chart24'];
		  	xScaler24.domain(d3.extent( locData.BM  , function(d) { return d.dt; }));
			
                        xOff = offset24;
                        yOff = offset24Y ;
                        // no idea why this is needed defaultOffset i mean ..
                        defaultOffset = 20;
                        hoverWidth = parseFloat($('.d3-tip').css("width"));
                        hoverHeight = parseFloat($('.d3-tip').css("height"));

                        if ( (xCoOrd < width24/2) )
                        {
                                xOff = xOff + width24 - hoverWidth + 2*margin.left;
				yOff += 2*hoverHeight;
                        }
			else if ( (xCoOrd >= width24/2) )
                        {
                                xOff = xOff + margin.left + margin.right;// + hoverWidth;
				yOff += 2*hoverHeight;
                        }


			hoverLine24.style("opacity", 1);
                        //circleBenchMark22.attr("opacity", 0.4);
                        tipLineChart22.transition().duration(200)
			.style("opacity", 0.7);
                        if ( xCoOrd >= (width24 + margin.left  ))
                                hoverLine24.attr("x1", width24  ).attr("x2", width24 ).style("opacity", 0.5);
                        else
                                hoverLine24.attr("x1", xCoOrd - marOffsetX ).attr("x2", xCoOrd - marOffsetX ).style("opacity", 0.5);
                        locDt = new Date ( xScaler24.invert(xCoOrd - marOffsetX) );
                        var formHtml = '';
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+">" +locDt.getDate()+" "+MnthRev[(locDt.getMonth())+1]+","+locDt.getFullYear() +" </p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:black\""+"> (Cumulative Returns) </p></strong>";
                        formHtml += retDailyData( locDt ,".chart24" );


                        tipLineChart22 .html( formHtml)
                                .style("left", (xOff ) + "px")
                                .style("top", (yOff) + "px");

                        // Use event.pageX / event.pageY here

                        })  .on("mouseout", function() {
                                console.log('bill');
                                tipLineChart22.transition().duration(200)
				.style("opacity",0);
                                hoverLine24.style("opacity",0);
                  });
                                  // Hover line.

			
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate(0," + height24 + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")



		//call the final rendering
		
		_reScaleBM_MF_axes(".chart24", "BULL3", 0); 	
		
		
	</script>
	</div>
	
	</div>

	<div id = "lowerHistContainer">
	
	<div id = "MFHist1">
	<svg class="histFlat3"></svg>
        <script>

		genHist(".histFlat3", "LV", 1);

	</script>	

	</div>

	
<!-- lower shite -->
</div>

	<script>
		//awkwaard placement of messsage	
		genMsg();		
	  $(function() {
		window.locList = [];
		for (idx = 0;idx < distSeries.length;idx++){
			locList.push(distSeries[idx]['idx_name']);
		} 
 
		$( "#search" ).autocomplete({
		  delay: 0,
		  source: locList,
		  select: function(event, ui) { 
		  //callback when option is selected
			console.log(ui.item.label)  ;
			$("#loader-wrapper").show();
			$.ajax({
        			type: "POST",
        			url: "http://ec2-52-77-217-54.ap-southeast-1.compute.amazonaws.com:8000/polls/",  // or just url: "/my-url/path/"
        			data: {
            				csrfmiddlewaretoken: '{{ csrf_token }}' ,
            				idx: ui.item.label
        			},
        			success: function(data) {
					$("#loader-wrapper").hide();
            				console.log("Congratulations! You scored: "+ data);
					var parsed = JSON.parse(data);
					refreshWithLatest(parsed, ajaxInd);
				
        			},
        			error: function(xhr, textStatus, errorThrown) {
            				alert("Please report this error: "+errorThrown+xhr.status+xhr.responseText);
        			}
    			});
		  }
		}) .focus(function() {
                                $( "#search" ).val('');
                   });
		
	  });

	$.widget( "custom.catcomplete", $.ui.autocomplete, {
		_create: function() {
		  this._super();
		  this.widget().menu( "option", "items", "> :not(.ui-autocomplete-category)" );
		},
		_renderMenu: function( ul, items ) {
		  var that = this,
			currentCategory = "";
		  $.each( items, function( index, item ) {
			var li;
			if ( item.category != currentCategory ) {
			  ul.append( "<li class='ui-autocomplete-category'>" + item.category + "</li>" );
			  currentCategory = item.category;
			}
			li = that._renderItemData( ul, item );
			if ( item.category ) {
			  li.attr( "aria-label", item.category + " : " + item.label );
			}
		  });
		}
		
	  });
	  
  	</script>

	<script>
			(function() {
	
				function init() {
					var speed = 50,
						easing = mina.easeinout;

					[].slice.call ( document.querySelectorAll( '#grid > a' ) ).forEach( function( el ) {
						var s = Snap( el.querySelector( 'svg' ) ), path = s.select( 'path' ),
							pathConfig = {
								from : path.attr( 'd' ),
								to : el.getAttribute( 'data-path-hover' )
							};

						el.addEventListener( 'mouseenter', function() {
							path.animate( { 'path' : pathConfig.to }, speed, easing );
							$("#info1").fadeIn();
							$("#HDR").fadeIn();
						} );

						el.addEventListener( 'mouseleave', function() {
							path.animate( { 'path' : pathConfig.from }, speed, easing );
							$("#info1").hide();
							$("#HDR").hide();
						} );
					} );
				}

				init();

			})();


		(function() {
    				document.onmousemove = handleMouseMove;
    					function handleMouseMove(event) {
        				var dot, eventDoc, doc, body, pageX, pageY;

        				event = event || window.event; // IE-ism

        // If pageX/Y aren't available and clientX/Y are,
        // calculate pageX/Y - logic taken from jQuery.
        // (This is to support old IE)
        				if (event.pageX == null && event.clientX != null) {
            					eventDoc = (event.target && event.target.ownerDocument) || document;
            					doc = eventDoc.documentElement;
           					 body = eventDoc.body;

            					event.pageX = event.clientX +
              						(doc && doc.scrollLeft || body && body.scrollLeft || 0) -
              						(doc && doc.clientLeft || body && body.clientLeft || 0);
            					event.pageY = event.clientY +
              						(doc && doc.scrollTop  || body && body.scrollTop  || 0) -
              						(doc && doc.clientTop  || body && body.clientTop  || 0 );
        				}

        // Use event.pageX / event.pageY here
    				      }
		     })();
		

			
	</script>

</body>
