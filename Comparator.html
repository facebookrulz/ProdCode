{% load staticfiles %}
<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<body>
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/spin.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/jquery-ui.min.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/component.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/component-button.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/normalize.css' %}">
<link rel="stylesheet" href="{% static 'jquery-ui-1.11.4.custom/bearbull.css' %}">
<script src="{% static 'jquery-ui-1.11.4.custom/external/jquery/jquery.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/jquery-ui.min.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/jquery.ui.slider.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/d3.min.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/external/jquery/d3-legend.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/dataManipulator.js' %}"></script>
<script src="{% static 'jquery-ui-1.11.4.custom/snap.svg-min.js' %}"></script>

<script>
//global VARIABLES
	
	window.master_array = new Array();	  
	window.bm_array = new Array();	  
	window.bm_Data_ = [];
	window.bins = [0.13,0.12,0.11,0.1,0.09,0.08,0.07,0.06,0.05,0.04,0.03,0.02,0.01,0,-0.01,-0.02,-0.03,-0.04,-0.05,-0.06,-0.07,-0.08,-0.09,-0.1,-0.11,-0.12,-0.13];
	//this will store the fund selected by the user
	window.current_MF_Data_ = [];
	window._BM_MF_FromDt_idx = -1;
	window._BM_MF_ToDt_idx = -1; 
	var colors = d3.scale.category20();
	//to be read from a static file
	window.MFVsBMHeight = (300*screen.width)/(1920);
	//since we have the graph continers as 67% of the width scale graph width in 1/3 proportion and subtract left and right margin
	window.MFVsBMWidth = ((screen.width)/3)-60;
	window.dispCircleRadius = 5;
	window.dispBMName = '';	
	window.dispMFName = '';
	window.isDragging = false;
	window.bnch = 'CNX Nifty';
	window.cmpAsset = "";
	window.assetType = "index";

        window.Mnth = {};
        window.MnthRev = {};
	window.storeAreaData = {};

        Mnth["Jan"]='01';
        Mnth["Feb"]='02';
        Mnth["Mar"]='03';
        Mnth["Apr"]='04';
        Mnth["May"]='05';
        Mnth["Jun"]='06';
        Mnth["Jul"]='07';
        Mnth["Aug"]='08';
        Mnth["Sep"]='09';
        Mnth["Oct"]='10';
        Mnth["Nov"]='11';
        Mnth["Dec"]='12';


        MnthRev[1]='Jan';
        MnthRev[2]='Feb';
        MnthRev[3]='Mar';
        MnthRev[4]='Apr';
        MnthRev[5]='May';
        MnthRev[6]='Jun';
        MnthRev[7]='Jul';
        MnthRev[8]='Aug';
        MnthRev[9]='Sep';
        MnthRev[10]='Oct';
        MnthRev[11]='Nov';
        MnthRev[12]='Dec';
	
	
	//given that both BM and MF will have the same dt range 
	//we can read the current BM values itself
	function findIndex(findDt){
		
		for(ctr = 0 ;ctr < bm_Data_.length; ctr++){
			if( (bm_Data_[ctr].dt).getTime() >= findDt.getTime() )
				return ctr;
		}
		return -1;
	}

	function genMsg(){
		//for now lets use averages of IQR and returns ..else lotsa if loops
		var retBetterOrWorse = ''
		var riskBetterOrWorse = ''
		var retBetterOrWorse1 = ''
		var riskBetterOrWorse1 = ''
		//first section for HV ..better or worse avg returns fr a phase as copared to the benchmark
		if ( (HVBMRet/2) > (HVAssetRet/2) && ((HVBMRet/2) - (HVAssetRet/2)) > 0.1 ){
			retBetterOrWorse = " lower ";	
		} 
		else if ( (HVBMRet/2) > (HVAssetRet/2) && ((HVBMRet/2) - (HVAssetRet/2)) < 0.1 )
			retBetterOrWorse = " similar ";	
		else if ( (HVBMRet/2) < (HVAssetRet/2) && ((HVBMRet/2) - (HVAssetRet/2)) < -0.1 )
                        retBetterOrWorse = " similar ";
		else
			retBetterOrWorse = " higher ";
		
		if ( HVBMIQR/2 > HVAssetIQR/2)
			riskBetterOrWorse = " lower ";
		else if ( HVBMIQR/2 < HVAssetIQR/2)
                        riskBetterOrWorse = " higher ";

		var HdrPara = 'The '+assetType+' '+cmpAsset+' has '+riskBetterOrWorse+' volatility during periods of High Volatility as compared to the benchmark. ';
		var Dtl =  'Looking at the High Volatility phases (Risk and return graphs to the LEFT ) one does notice the '+assetType+' '+cmpAsset+' has returns that are '+retBetterOrWorse+' as compared to the benchmark for a '+riskBetterOrWorse+' risk. ';
		
		//now generate message for Low Volatility		
		if ( (LVBMRet/2) > (LVAssetRet/2) && ((LVBMRet/2) - (LVAssetRet/2)) > 0.1 ){
			retBetterOrWorse1 = " lower ";	
		} 
		else if ( (LVBMRet/2) > (LVAssetRet/2) && ((LVBMRet/2) - (LVAssetRet/2)) < 0.1 )
			retBetterOrWorse1 = " similar ";	
		else if ( (LVBMRet/2) < (LVAssetRet/2) && ((LVBMRet/2) - (LVAssetRet/2)) < -0.1 )
                        retBetterOrWorse1 = " similar ";
		else
			retBetterOrWorse1 = " higher ";
		
		if ( LVBMIQR/2 > LVAssetIQR/2)
			riskBetterOrWorse1 = " lower ";
		else if ( LVBMIQR/2 < LVAssetIQR/2)
                        riskBetterOrWorse1 = " higher "; 


		HdrPara = HdrPara + 'During periods of Low Volatility it has '+riskBetterOrWorse1+' volatility . ';
		Dtl = Dtl + 'During Low Volatility (Risk and return graphs below) ,  it has returns that are '+retBetterOrWorse1+' as compared to the benchmark for a '+riskBetterOrWorse1+' risk. ';
		var addendum = '';	

		if(riskBetterOrWorse == " higher " && riskBetterOrWorse1 == " higher "){
			if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " higher "){
				Dtl = Dtl +  cmpAsset+' is a steady bet in BULLISH / LOW Volatility Phases and BEARISH phases.';
			}
			else if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " lower ")
				Dtl = Dtl + cmpAsset+' is a better bet in BULLISH / LOW Volatility Phases but NOT during BEARISH phases.';
			else
				Dtl = Dtl + cmpAsset+' is better avoided since it has higher volatility but lower returns across phases!!';
		}	
		else if(riskBetterOrWorse == " lower " && riskBetterOrWorse1 == " lower "){
			if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " higher "){
				Dtl = Dtl +  cmpAsset+' has high odds of beating the market in BULLISH / LOW Volatility Phases and BEARISH phases.';
			}
			else if (retBetterOrWorse1 ==  " higher " && retBetterOrWorse ==  " lower ")
				Dtl = Dtl + cmpAsset+' is a safe bet in BULLISH / LOW Volatility Phases but NOT during BEARISH phases.';
		}	

	
		document.getElementById("Header1").innerHTML = 'Performance - Volatility Vs Returns'; 	
		document.getElementById("Header1-Para").innerHTML = HdrPara +'. To know more hover over me ...'; 	
		document.getElementById("DetailedHeader1").innerHTML = Dtl;	
	}

	$(document).ready(function(){
		$("#loader-wrapper").hide();
		$("#info1").hide();
		$("#HDR").hide();
	});
	
	// to be called initially
	function initGlobalSetBM( passLL, passHist, passTS, passDist, passIQR){
			console.log('FUCKER '+screen.width);	
			//FOR NOW use 0 index .. but we need to have a map
			// for MF data and bm index
			window.HVBMRet = 0.0;
			window.HVAssetRet = 0.0;
			window.LVBMRet = 0.0;
			window.LVAssetRet = 0.0;
			
			window.HVBMIQR = 0.0;
			window.HVAssetIQR = 0.0;
			window.LVBMIQR = 0.0;
			window.LVAssetIQR = 0.0;

			window.bm_Data_ = retDefaultBMData();
			//below 2 are python/django data
			if( passLL === undefined && passHist === undefined && passTS === undefined && passDist === undefined){
				window.tsList = {{ ll_list|safe  }};
				window.histList = {{ hist|safe  }};
				window.timeSeries = {{ ll|safe  }};
				window.distSeries = {{ dist_ll|safe  }};
				window.IQRList = {{ IQR|safe  }};
			}	
			else{
				window.tsList = passLL;
                                window.histList = passHist;
                                window.timeSeries = passTS;
                                window.distSeries = passDist;
				window.IQRList = passIQR;
			}

		
			if(tsList[0]['idx_name'] != bnch)
				cmpAsset = tsList[0]['idx_name'];
			else
				cmpAsset = tsList[1]['idx_name'];

			console.log('BATMAN '+cmpAsset+tsList[0]['idx_name']+'-'+tsList[1]['idx_name']+'-'+histList.length+'-'+histList['CNX Smallcap-FLAT2\r']);	
			window.timeSeriesDict = {};
			window.timeSeriesZeroDict = {};
			window.histMaster = {};	
			initTS();
			initHIST();

			dispBMName = retDefaultBMName();
			var format = d3.time.format( "%d-%b-%y" );
			window.bm_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					d.closing = +d.closing;
				  });
			console.log(' JUST FINISHED !!');	  
		//first time user sees chart she should be able to see only 50% of the total time period	  
		//then these 2 values are continually updtd in dragslider function
			if(window._BM_MF_FromDt_idx == -1 && window._BM_MF_ToDt_idx == -1){
				_BM_MF_FromDt_idx = Math.round( bm_Data_.length*(0.5) );	
				_BM_MF_ToDt_idx = bm_Data_.length-1;	  
			}
		//initialize the autocomplete list
		

	}	 

	function refreshWithLatest( neo_data ){
		
		initGlobalSetBM(neo_data['ll_list'],neo_data['hist'],neo_data['ll'],neo_data['dist_ll'],neo_data['IQR']);

		_reScaleBM_MF_axes( ".chart2", "FLAT1",  1);
		_reScaleBM_MF_axes( ".chart22", "FLAT2", 0);
		_reScaleBM_MF_axes( ".chart23" , "BULL2", 1); 
		_reScaleBM_MF_axes(".chart24", "BULL3", 0);
		
		d3.selectAll(".bar").remove();
		d3.selectAll(".bar1").remove();

		//first numeric arg is uper /lower and the 2nd one indicates if its a screen refresh
		genHist(".histFlat1", "FLAT1", 0);
		genHist(".histFlat2", "FLAT2", 0);
		genHist(".histFlat3", "BULL2", 1);
		genHist(".histFlat4", "BULL3", 1);
		
		genMsg();
	
	}

	function retDailyData(  dt, area){
		locNm = '';

		//check for sat and sunday ...if so pass the function day-1 or 2 accordingly
		if (dt.getDay() == 6)
			dt = new Date(dt.setDate(dt.getDate() - 1));
		else if (dt.getDay() == 0)
                        dt = new Date(dt.setDate(dt.getDate() - 2));

		locData = storeAreaData[ [area] ];
		data = locData.BM;
		dataAss = locData.ASS;
		
                for(ctr = 0 ; ctr < data.length; ctr++)
                {
                        lcDt = data[ctr].dt;
                        if ( dt.getFullYear() == lcDt.getFullYear() && dt.getMonth() == lcDt.getMonth() && dt.getDate() == lcDt.getDate()  ) {
                                        var per = data[ctr];
                                        var per1 = dataAss[ctr];
                                         ret = Math.round(per.cumuChg*100*100)/100 ;
                                         ret1 = Math.round(per1.cumuChg*100*100)/100 ;
					 console.log('nam '+ret+' '+ret1);
                                         if (ret > 0)
                                                locNm += "<strong><p style="+"\"color:black\""+">"+bnch+" : "+ ret + "% </p></strong>";
                                         else
                                                locNm += "<strong><p style="+"\"color:red\""+">"+bnch+" : "+ ret + "% </p></strong>";

                                         if (ret1 > 0)
                                                locNm += "<strong><p style="+"\"color:black\""+">"+cmpAsset+" : "+ ret1 + "% </p></strong>";
                                         else
                                                locNm += "<strong><p style="+"\"color:red\""+">"+cmpAsset+" : "+ ret1 + "% </p></strong>";
					 
					 return locNm;	
                        }
                }
                return "<strong><p style="+"\"color:steelblue\""+">"+locNm+": Markets Closed</p></strong>";

	}

	function retHistBinData(asset, phase){
		locList =  Object.keys(histMaster);
		
		for(histCtr = 0; histCtr< locList.length ; histCtr++){
			if ( locList[histCtr].indexOf( asset+'-'+phase ) > -1){
				return histMaster[locList[histCtr]]; 
			}
		}

		return -1;
	}
	
	function adder(a ){	
		var store = 0;
		for(Ctr = 0; Ctr< a.length ; Ctr++){
			store = store + a[Ctr]['value']
		}
	return store;	
	}
	
	
	function initHIST(){
	locList =  Object.keys(histList);
	var _chg_ = [];
                
		for(histCtr = 0; histCtr< locList.length ; histCtr++){
                        valArr = histList[locList[histCtr]];
			
			for(valCtr =0; valCtr < valArr.length; valCtr++){
        			var singleObj = {};
				singleObj['name'] = bins[valCtr];
                        	singleObj['value'] = valArr[valCtr];
				_chg_.push(singleObj)	
			}
			
		   histMaster[locList[histCtr]]=_chg_;	
		   _chg_ = [];	
                }

	}

	function initTS(){
		var phase = timeSeries[ 0 ].Phase;
   		var idx = timeSeries[ 0 ].idx_name;
   		var _per_chg_ = [];
		var cumSum = 0.0;

   		for (tsCtr = 1; tsCtr < timeSeries.length; tsCtr++){
        		var singleObj = {};
			var storeDt = ( timeSeries[ tsCtr ].idx_dt );
			var storeChg = ( timeSeries[ tsCtr ].cumChg );
			cumSum = cumSum + storeChg;
        			if( (timeSeries[ tsCtr ].Phase != phase || timeSeries[ tsCtr ].idx_name != idx) && _per_chg_.length > 0 ){
                			timeSeriesDict[idx+'-'+phase] = _per_chg_;
					//console.log(_per_chg_);	
                			phase = timeSeries[ tsCtr ].Phase;
                			idx = timeSeries[ tsCtr ].idx_name;
                			_per_chg_ = [];
					cumSum = 0.0;	
       				 }	
        		singleObj['dt'] = storeDt;
        		singleObj['cumuChg'] = cumSum;
			singleObj['zero'] = 0.0;
        		_per_chg_.push(singleObj);
   		}
		//fr the lst pair combo simply insert because it will come out when the tsCtr index reaches length
		timeSeriesDict[idx+'-'+phase] = _per_chg_;
	console.log('in initTS '+Object.keys(timeSeriesDict));

	}



	function retRelevantData( phase, asset ){
	console.log('in retRelevantData '+ asset+'-'+phase);
		var key_list = Object.keys(timeSeriesDict);
		var key_ctr = 0;
		while (key_ctr < key_list.length){
			//ding this because there seems to be some extra harecters being returned by key list ..i think its comeing from the db
 			// need to find method to trim extra chars
			console.log(key_list[key_ctr]);
			if(key_list[key_ctr].indexOf(asset+'-'+phase) > -1) break;
			key_ctr++;
		}
	//console.log('in retRelevantData '+timeSeriesDict[key_list[key_ctr]]);
	return timeSeriesDict[key_list[key_ctr]]
	}

        
	
	function setBMDataBasedOnMF(_mf_name){
		dispBMName = retBMName(_mf_name);
		dispMFName = _mf_name;
		bm_Data_ = retBMData(_mf_name);
		
		window.current_MF_Data_ = retMFData (_mf_name);
		console.log();
		//init
		bm_Data_.forEach(function(d) {
					
					d.dt = new Date(d.dt);
					
					d.closing = +d.closing;
				  });
		current_MF_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					
					d.closing = +d.closing;
				  });
				  
		console.log("IN setBMDataBasedOnMF value of MF "+_mf_name+" and length "+ current_MF_Data_.length);
	}
	
	function _reScaleBM_MF_axes( area, phase, showLegend ){

		var margin = {top: 20, right: 30, bottom: 20, left: 30};
	if (current_MF_Data_.length == 0){	  
				  current_MF_Data_ = bm_Data_;
				  }
			//both slices will have window prefix since we intend to use them outside this function	
			//defensive coding
			//if(_BM_MF_FromDt_idx >= 0 && _BM_MF_ToDt_idx >= 0){	
				window.sliced_bm_Data_ = retRelevantData(phase, bnch);
			
				//if(init_Data_ != null) //meaning its being called by click on mf circle ; else init
				//	current_MF_Data_ = init_Data_;
				console.log('GRRRRR '+cmpAsset);	
				window.current_Data_ = retRelevantData(phase, cmpAsset);
			//}
			
			sliced_bm_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					d.cumuChg = +d.cumuChg;
					d.zero = +d.zero;
				  });
			
			current_Data_.forEach(function(d) {
					d.dt = new Date(d.dt);
					d.cumuChg = +d.cumuChg;
					d.zero = +d.zero;
				  });

			//store the data structures for recall in hovers
			var singleTon = {};
			singleTon['BM'] = sliced_bm_Data_;
			singleTon['ASS'] = current_Data_;
			storeAreaData[ [area] ] = singleTon;		
			
			var mindt = new Date(); var maxdt = new Date(); var minClose = 0; var maxClose = 0;
			// figure out the min and max shite
			if( d3.max(sliced_bm_Data_, function(d) { return d.cumuChg; }) > d3.max(current_Data_, function(d) { return d.cumuChg; }) )
				maxClose = d3.max(sliced_bm_Data_, function(d) { return d.cumuChg; });
			else
				maxClose = d3.max(current_Data_, function(d) { return d.cumuChg; });
				
			if( d3.min(sliced_bm_Data_, function(d) { return d.cumuChg; }) < d3.min(current_Data_, function(d) { return d.cumuChg; }) )
				minClose = d3.min(sliced_bm_Data_, function(d) { return d.cumuChg; });
			else
				minClose = d3.min(current_Data_, function(d) { return d.cumuChg; });
				
			if( d3.max(sliced_bm_Data_, function(d) { return d.dt; }) > d3.max(current_Data_, function(d) { return d.dt; }) )
				maxdt = d3.max(sliced_bm_Data_, function(d) { return new Date(d.dt); });
			else
				maxdt = d3.max(current_Data_, function(d) { return new Date(d.dt); });
				
			if( d3.min(sliced_bm_Data_, function(d) { return d.dt; }) < d3.min(current_Data_, function(d) { return d.dt; }) )
				mindt = d3.min(sliced_bm_Data_, function(d) { return new Date(d.dt); });
			else
				mindt = d3.min(current_Data_, function(d) { return new Date(d.dt); });
			//
			
			var xScaler = d3.time.scale()
			.range([0, LCCWidth]);

			var yScaler = d3.scale.linear()
			.range([LCCHeight , 0]);
			
			var xAxis = d3.svg.axis()
			.scale(xScaler)
			.orient("bottom")
			//.innerTickSize(-LCCHeight)
                        //.outerTickSize(0)
			.tickFormat(d3.time.format("%b"));

			var yAxis = d3.svg.axis()
			.scale(yScaler)
			.orient("left")
			//.tickValues([-1,-0.5, -0.25, 0,0.05 ,0.10, 0.25 ,0.5,1])
			.innerTickSize(-LCCWidth)
                        .outerTickSize(0)
			.tickFormat(d3.format("%"));
			
			var line = d3.svg.line()
						.x(function(d) { return xScaler((d.dt)); })
						.y(function(d) { return yScaler(d.cumuChg); });

			var line1 = d3.svg.line()
						.x(function(d) { return xScaler((d.dt)); })
						.y(function(d) { return yScaler(d.zero); });

			var svg = d3.select(area);
			
			//clear existing
			svg.selectAll("path")
			.remove();
			
			//svg.selectAll("text").remove();
			//rescale if necessary
			
			xScaler.domain([mindt, maxdt]);
			yScaler.domain([minClose, maxClose]);
			
// the below code handles putting labels at the end of line charts
				BMperiodRet = sliced_bm_Data_[sliced_bm_Data_.length-1]['cumuChg'];
				AssetperiodRet = current_Data_[current_Data_.length-1]['cumuChg'];
				if (phase == 'FLAT1' || phase == 'FLAT2'){
					HVBMRet = HVBMRet + BMperiodRet;
					HVAssetRet = HVAssetRet + AssetperiodRet;
				}	
				else if (phase == 'BULL2' || phase == 'BULL3'){
                                        LVBMRet = LVBMRet + BMperiodRet;
                                        LVAssetRet = LVAssetRet + AssetperiodRet;
                                }

				var t1 = yScaler(BMperiodRet);
				var t2 = yScaler(AssetperiodRet);
				if( t1 == 0 ) t1=t1+10;
				if( t2 == 0 ) t2=t2+10;
				if( t1 == LCCHeight ) t1 = LCCHeight - 10;
				if( t2 == LCCHeight ) t2 = LCCHeight - 10;
					
				console.log('t1 t2 '+t1+' '+t2);

				if ( t1 > t2 && Math.abs(t1-t2) < 50 ){
					if(LCCHeight - t1 < 50){
						t1 = LCCHeight - 50;
					}
						t2 = t1 - 50;
				}	
				else if( t1 < t2 && Math.abs(t1-t2) < 50 ){
                                        if( t1 < 50){
                                                t1 = 50;
                                        }
                                                t2 = t1 + 50;
                                }

			
			svg.select(".y.axis").transition().duration(500).ease("sin-in-out")  // https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
                    .call(yAxis); 
		    svg.select(".x.axis").transition().duration(500).ease("sin-in-out")  // https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
                    .call(xAxis); 	
		
			
			//add benchmark
		if( showLegend == 1){
			window.benchMarkPath =	svg.append("path")
			  .datum(sliced_bm_Data_)
			  .attr("class", "line")
			  .attr("d", line)
			  //.attr("data-legend", bnch)
			  .attr("stroke","#5DA5DA")
			  .attr("transform", "translate("+marOffsetX+","+marOffsetY+")")

		}
		else{
			window.benchMarkPath =	svg.append("path")
			  .datum(sliced_bm_Data_)
			  .attr("class", "line")
			  .attr("d", line)
			  //.attr("data-legend", 'Returns - '+phase)
			  .attr("stroke","#5DA5DA")
			  .attr("transform", "translate("+marOffsetX+","+marOffsetY+")")
		}
		//zero line
	  
			//if the user hath selected some MF  
			if( showLegend == 1){
				window.MFPath = svg.append("path")
				  .datum(current_Data_)
				  .attr("class", "line")
				  .attr("d", line)
				  //.attr("data-legend", cmpAsset)
				  .attr("stroke","#F15854")
				  .attr("transform", "translate("+marOffsetX+","+marOffsetY+")")
			} else {
				window.MFPath = svg.append("path")
				  .datum(current_Data_)
				  .attr("class", "line")
				  .attr("d", line)
				  .attr("stroke","#F15854")
				  .attr("transform", "translate("+marOffsetX+","+marOffsetY+")")
			
			}		  
			


			svg.selectAll(".legend").remove();
			//now set to and from dt calendars and also dragslider positions
			
			if ( _BM_MF_FromDt_idx < _BM_MF_ToDt_idx) {
				$( "#FromDt" ).datepicker( "setdt",  bm_Data_[_BM_MF_FromDt_idx].dt );
				$( "#ToDt" ).datepicker( "setdt",  bm_Data_[_BM_MF_ToDt_idx].dt );	
				$( "#dragslider-range" ).dragslider( "values" , [ _BM_MF_FromDt_idx , _BM_MF_ToDt_idx] )	
			}
			else{
				//better error handling ..for now just alert
				alert("sorry from dt's always going to be earlier than To dt ..never went to school ..sucker ?");
			}	

			/* if( showLegend == 1){				
				legend = svg.append("g")
				.attr("class","legend")
				.attr("transform","translate(70,25)")
				.style("font-size","15px")
				.attr("data-style-padding",10)
				.call(d3.legend);
			}
			*/
// the below code handles putting labels at the end of line charts
				BMperiodRet = sliced_bm_Data_[sliced_bm_Data_.length-1]['cumuChg'];
				AssetperiodRet = current_Data_[current_Data_.length-1]['cumuChg'];
				if (phase == 'FLAT1' || phase == 'FLAT2'){
					HVBMRet = HVBMRet + BMperiodRet;
					HVAssetRet = HVAssetRet + AssetperiodRet;
				}	
				else if (phase == 'BULL2' || phase == 'BULL3'){
                                        LVBMRet = LVBMRet + BMperiodRet;
                                        LVAssetRet = LVAssetRet + AssetperiodRet;
                                }

// text element indicating phase gain / loss
/*
				svg.append("text")
					.attr("transform", "translate(" + (width+3) + "," + t1 + ")")
					.attr("dy", ".35em")
					.attr("font-size", "18px")
					.attr("text-anchor", "start")
					.style("fill", "#5DA5DA")
					.style("font-weight", "bold")
					.text(Math.floor(BMperiodRet * 100)+'%' );

				svg.append("text")
					.attr("transform", "translate(" + (width+3) + "," + t2 + ")")
					.attr("dy", ".35em")
					.attr("font-size", "18px")
					.attr("text-anchor", "start")
					.style("fill", "#F15854")
					.style("font-weight", "bold")
					.text(Math.floor(AssetperiodRet * 100)+'%' );
*/			

    }
	

	function genHist( area, phase , container ){

		var margin = {top: 20, right: 30, bottom: 20, left: 30};
	
		
		if(container == 0){
                	width = parseFloat ($("#upperHistContainer").css("width"))/2 - 2*margin.left - 2*margin.right,
                	height = parseFloat ($("#upperHistContainer").css("height")) - margin.top - margin.bottom;
		}
		else
		{
                	width = parseFloat ($("#upperHistContainer").css("width"))/2 - 2*margin.left - 2*margin.right,
                	height = parseFloat ($("#upperHistContainer").css("height")) - margin.top - margin.bottom;
		}
		var xHist = d3.scale.ordinal()
			.rangeRoundBands([width,0], 0.1);
		var yHist = d3.scale.linear()
			.range([height,0]);

		var xAxis = d3.svg.axis()
			.scale(xHist)
			.orient("bottom")
			.tickValues([-0.12,-0.06,-0.02,0, 0.02, 0.04, 0.08, 0.13])
			.tickFormat(d3.format("%"));


		var yAxis = d3.svg.axis()
			.scale(yHist)
			.orient("left");
		
		var bnchData = retHistBinData( bnch, phase);
		var assData = retHistBinData( cmpAsset , phase);
		var normbnch = adder(bnchData);
		var normass = adder(assData);

		window.barChart22 = d3.select("body")
                                .append("div-tool")  // declare the tooltip div
                                .attr("class", "d3-tip")              // apply the 'tooltip' class
                                .style("opacity", 0);



		console.log('ass '+normbnch+'-'+normass);
		console.log('asshole '+ IQRList[bnch+'-'+phase+'\r']);

		if (phase == 'FLAT1' || phase == 'FLAT2'){
                                        HVBMIQR = HVBMIQR + IQRList[bnch+'-'+phase+'\r'];
                                        HVAssetIQR = HVAssetIQR + IQRList[cmpAsset+'-'+phase+'\r'];
                }
                else if (phase == 'BULL2' || phase == 'BULL3'){
                                        LVBMIQR = LVBMIQR + IQRList[bnch+'-'+phase+'\r'];
                                        LVAssetIQR = LVAssetIQR + IQRList[cmpAsset+'-'+phase+'\r']; 
                }


		xHist.domain(bnchData.map(function(d) { return d.name; }));
		if( d3.max( bnchData , function(d) { return d.value; }) > d3.max(assData , function(d) { return d.value; }) )
			yHist.domain([0, d3.max(bnchData , function(d) { return d.value/normbnch; })]);
		else
			yHist.domain([0, d3.max(assData , function(d) { return d.value/normass; })]);

		var chart = d3.select(area)
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		chart.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate(0," + height + ")")
			  .call(xAxis);


		chart.selectAll(area)
			  .data(bnchData)
			.enter().append("rect")
			  .attr("class", "bar")
			  .attr("x", function(d) { return xHist(d.name)+3; })
			  .attr("y", function(d) { return yHist(d.value/normbnch); })
			  .attr("height", function(d) { return height - yHist(d.value/normbnch); })
			  .attr("width", xHist.rangeBand()-5)
			  .on('click', function(d,i){  alert( d.value/normbnch ) ; })
			  .on('dblclick', function(d,i){  alert( d.name ) ; });

		chart.selectAll(area)
			  .data(assData)
			.enter().append("rect")
			  .attr("class", "bar1")
			  .attr("x", function(d) { return xHist(d.name); })
			  .attr("y", function(d) { return yHist(d.value/normass); })
			  .attr("height", function(d) { return height - yHist(d.value/normass); })
			  .attr("width", xHist.rangeBand())
			  //.attr("data-legend", "Volatility - "+phase)
			  .on('click', function(d,i){  alert( d.value/normbnch ); })
			  .on('dblclick', function(d,i){  alert( d.name ); });

                d3.select(area)
                        .on("mouseover", function() {

                          console.log('mouseover bugs');

                        })
                        .on("mousemove", function() {
                          var xCoOrd = d3.mouse(this)[0];
                          var yCoOrd = d3.mouse(this)[1];
			  var normbnch = adder(bnchData);
                          var normass = adder(assData);	
			  var bnchDist = 0.0;
			  var cmpDist = 0.0;
			  var range = '';	
	
			  offsetBinX = 0.0;	
			  offsetBinY = 0.0;	

			  console.log(' vik '+event.pageX+' '+event.pageY+' '+parseFloat( $("#upperLCContainer").css("height"))+' '+parseFloat( $("#upperLCContainer").css("width")));	
			  // user x and y co ords for finding offset

			  if ( event.pageX < parseFloat( $("#upperLCContainer").css("width"))/2 && event.pageY <  parseFloat( $("#upperHouse").css("width")) ){ 
				//first hist from top left
				offsetBinX = margin.left;	
				offsetBinY = parseFloat( $("#upperLCContainer").css("height"));	
			  }	
			  else if ( event.pageX > parseFloat( $("#upperLCContainer").css("width"))/2 && event.pageY <  parseFloat( $("#upperHouse").css("width"))  ){ 
				//2nd hist from top left
				offsetBinX = 2*margin.left +  parseFloat( $("#upperLCContainer").css("width"))/2;	
				offsetBinY = parseFloat( $("#upperLCContainer").css("height"));	
			  }
			  else if ( screen.width - event.pageX < parseFloat( $("#lowerLCContainer").css("width"))/2 &&  event.pageY >  parseFloat( $("#upperHouse").css("width"))  )
			  {
				//4th hist bottom right
				offsetBinX = margin.left +  screen.width - parseFloat( $("#lowerLCContainer").css("width"))/2;	
				offsetBinY = parseFloat( $("#upperHouse").css("height")) + parseFloat( $("#lowerLCContainer").css("height")) + margin.top*4 ;	
			  }
			  else if ( screen.width - event.pageX < parseFloat( $("#lowerLCContainer").css("width")) &&  event.pageY >  parseFloat( $("#upperHouse").css("width"))  )
			  {
				//3rd hist bottom right
				offsetBinX = margin.left +  screen.width - parseFloat( $("#lowerLCContainer").css("width"));	
				offsetBinY = parseFloat( $("#upperHouse").css("height")) + parseFloat( $("#lowerLCContainer").css("height")) + margin.top*4 ;	
			  }				
			

			  flg = bnchData[0];	
			  for (cr = 0; cr < bnchData.length ; cr++){
				//console.log('FREAK '+cr+' '+xHist( bnchData[cr].name )+' '+xCoOrd+' '+xHist( flg.name ) );
			  	if ( (xHist( bnchData[cr].name ) - 8.5 ) < (xCoOrd) && (xCoOrd) < (xHist( bnchData[cr].name ) + 8.5 )  )
				{
					console.log("Clicked on " + bnchData[cr+3].name +'- '+ bnchData[cr+2].name+' '+(parseFloat(bnchData[cr+2].value)/normbnch)*100+' '+(parseFloat(assData[cr+2].value)/normbnch)*100);
					bnchDist = Math.round((parseFloat(bnchData[cr+2].value)/normbnch)*100);
					cmpDist = Math.round( (parseFloat(assData[cr+2].value)/normbnch)*100);
					range = parseFloat( bnchData[cr+3].name )*100+' To '+ parseFloat( bnchData[cr+2].name )*100+' %';
					break;
				}
				flg = bnchData[cr];
			  }

                        xOff = offsetBinX;
                        yOff = offsetBinY;
                        // no idea why this is needed defaultOffset i mean ..
                        defaultOffset = 20;
                        hoverWidth = parseFloat($('.d3-tip').css("width"));
                        hoverHeight = parseFloat($('.d3-tip').css("height"));

                        if ( (xCoOrd < width/2) )
                        {
                                xOff += width - hoverWidth + 2*margin.left;
                                yOff += 2*hoverHeight;
                        }
                        else if ( (xCoOrd >= width/2) )
                        {
                                xOff += margin.left + margin.right;// + hoverWidth;
                                yOff += 2*hoverHeight;
                        }


                        tipLineChart22.transition().duration(200)
                        .style("opacity", 0.7);
                        var formHtml = '';
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+">"+" Daily % Chg Distribution </p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:steelblue; font-size:20px;\""+">"+range+ "</p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:black\""+">"+bnch+" : "+ bnchDist +"%</p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:black\""+">"+cmpAsset+" : "+ cmpDist +"%</p></strong>";


                        tipLineChart22 .html( formHtml)
                                .style("left", (xOff ) + "px")
                                .style("top", (yOff) + "px");
	


			  //console.log( "MUDKA "+xCoOrd+' '+' '+yCoOrd+' '+ width1+' ' + width );
			})
			  .on("mouseout", function() {
				tipLineChart22.transition().duration(200)
                        	.style("opacity", 0.01);
                        });

/*
		chart.append("g")
			.attr("class","legend")
			.attr("transform","translate(0,25)")
			.style("font-size","15px")
			.attr("data-style-padding",10)
			.call(d3.legend);	
*/
		//});

		function type(d) {
		  d.value = +d.value; // coerce to number
		  return d;
		}
	}
</script>

	<div id = "HDR1">
               <p id="HeaderButton">
		 <button class="btn btn-7 btn-7a ">Fund Of Funds</button>
               	 <button class="btn btn-7 btn-7a ">Fund House</button>
		 <button class="btn btn-7 btn-7a ">Fund Manager</button>
               	 <button class="btn btn-7 btn-7a ">Synthetic Portfolios</button>
	       </p>
	</div>


	

	<div id="loader-wrapper">
    		<div id="loader"></div>
	</div>

<!-- begin container for upper shite -->
<div id="upperHouse">

	<div id = "upperLCContainer">
	<div id = "MFvsBM">
	<svg class="chart2" id="OK"></svg>
	<script>
		initGlobalSetBM();	

		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width2 = parseFloat( $("#upperLCContainer").css("width") )/2 - 2*margin.left - 2*margin.right,
                height2 = parseFloat( $("#upperLCContainer").css("height") ) - margin.top - margin.bottom;
		//width = 700 , height = 500 ;
		window.offset2 =  margin.left; 
		window.LCCWidth = width2;
		window.LCCHeight = height2;

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler2 = d3.time.scale()
			.range([0, width2]);

		var yScaler2 = d3.scale.linear()
			.range([height2, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler2)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler2)
			.orient("left");

		var svg = d3.select(".chart2")
			.attr("width", width2 + margin.left + margin.right)
			.attr("height", height2 + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
		 //add hover line
                var hoverLineGroup = svg.append("g")
                                  .attr("class", "hover-line");

                window.hoverLine2 = hoverLineGroup
                                .append("line")
                                .attr("x1", 0).attr("x2", 0)
                                .attr("y1", 0).attr("y2", height2)
                                .style("opacity", 0.1);

                  // Hover line.



                d3.select(".chart2")
			.on("mouseover", function() {

                          console.log('mouseover bugs');

                        })
			.on("mousemove", function() {
                          var xCoOrd = d3.mouse(this)[0];
                          var yCoOrd = d3.mouse(this)[1];

			if ( xCoOrd >= (width2 + margin.left +2 )) return 1;
			if ( xCoOrd < margin.left) return 1;

			console.log('DEUCHE '+xCoOrd+' '+yCoOrd);
		  	locData = storeAreaData['.chart2'];
		  	xScaler2.domain(d3.extent( locData.BM  , function(d) { return d.dt; }));
			
                        xOff = offset2;
                        yOff = 0.0;
                        // no idea why this is needed defaultOffset i mean ..
                        defaultOffset = 20;
                        hoverWidth = parseFloat($('.d3-tip').css("width"));
                        hoverHeight = parseFloat($('.d3-tip').css("height"));

                        if ( (xCoOrd < width2/2) )
                        {
                                xOff = xOff + width2 - hoverWidth + 2*margin.left;
				yOff = 2*hoverHeight;
                        }
			else if ( (xCoOrd >= width2/2) )
                        {
                                xOff = xOff + margin.left + margin.right;// + hoverWidth;
				yOff = 2*hoverHeight;
                        }


			hoverLine2.style("opacity", 1);
                        //circleBenchMark22.attr("opacity", 0.4);
                        tipLineChart22.transition().duration(200)
			.style("opacity", 0.7);
                        if ( xCoOrd >= (width2 + margin.left  ))
                                hoverLine2.attr("x1", width2  ).attr("x2", width2 ).style("opacity", 0.5);
                        else
                                hoverLine2.attr("x1", xCoOrd - marOffsetX ).attr("x2", xCoOrd - marOffsetX ).style("opacity", 0.5);
                        locDt = new Date ( xScaler2.invert(xCoOrd - marOffsetX) );
                        var formHtml = '';
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+">" +locDt.getDate()+" "+MnthRev[(locDt.getMonth())+1]+","+locDt.getFullYear() +" </p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+"> (Cumulative Returns) </p></strong>";
                        formHtml += retDailyData( locDt ,".chart2" );


                        tipLineChart22 .html( formHtml)
                                .style("left", (xOff ) + "px")
                                .style("top", (yOff) + "px");

                        // Use event.pageX / event.pageY here

                        })  .on("mouseout", function() {
                                console.log('bill');
                                tipLineChart22.transition().duration(200)
				.style("opacity",0);
                                hoverLine2.style("opacity",0);
                  });
                                  // Hover line.

			
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate(0," + height2 + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")



		//call the final rendering
		_reScaleBM_MF_axes( ".chart2", "FLAT1", 1); 	
		
		
	</script>
		
	
	</div>



	<div id = "MFvsBM">
	<svg class="chart22" id="OK"></svg>
	<script>	
		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width22 = parseFloat( $("#upperLCContainer").css("width") )/2 - 2*margin.left - 2*margin.right,
                height22 = parseFloat( $("#upperLCContainer").css("height") ) - margin.top - margin.bottom;
		//width = 700 , height = 500 ;
		window.offset22 = parseFloat( $("#upperLCContainer").css("width") )/2 + margin.left; 

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler22 = d3.time.scale()
			.range([0, width22]);

		var yScaler22 = d3.scale.linear()
			.range([height22, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler22)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler22)
			.orient("left");

		var svg = d3.select(".chart22")
			.attr("width", width22 + margin.left + margin.right)
			.attr("height", height22 + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
		 //add hover line

                  // Hover line.
                var hoverLineGroup = svg.append("g")
                                  .attr("class", "hover-line");

                window.hoverLine22 = hoverLineGroup
                                .append("line")
                                .attr("x1", 0).attr("x2", 0)
                                .attr("y1", 0).attr("y2", height22)
				.style("opacity", 0.1);
                        // Hide hover line by default.


                window.tipLineChart22 = d3.select("body")
                //window.tipLineChart = svg 
                                .append("div-tool")  // declare the tooltip div
                                .attr("class", "d3-tip")              // apply the 'tooltip' class
                                .style("opacity", 0);


               circleBenchMark22 = svg.append("circle")
                                .attr("opacity", 0.00001)
                                .attr({ r: dispCircleRadius, fill: 'red' });



                d3.select(".chart22")
			.on("mouseover", function() {

                          console.log('mouseover bugs');

                        })
			.on("mousemove", function() {
                          var xCoOrd = d3.mouse(this)[0];
                          var yCoOrd = d3.mouse(this)[1];

			if ( xCoOrd >= (width22 + margin.left +2 )) return 1;
			if ( xCoOrd < margin.left) return 1;

			console.log('DEUCHE '+xCoOrd+' '+yCoOrd);
		  	locData = storeAreaData['.chart22'];
		  	xScaler22.domain(d3.extent( locData.BM  , function(d) { return d.dt; }));
			
                        xOff = offset22;
                        yOff = 0.0;
                        // no idea why this is needed defaultOffset i mean ..
                        defaultOffset = 20;
                        hoverWidth = parseFloat($('.d3-tip').css("width"));
                        hoverHeight = parseFloat($('.d3-tip').css("height"));

                        if ( (xCoOrd < width22/2) )
                        {
                                xOff = xOff + width22 - hoverWidth + 2*margin.left;
				yOff = 2*hoverHeight;
                        }
			else if ( (xCoOrd >= width22/2) )
                        {
                                xOff = xOff + margin.left + margin.right;// + hoverWidth;
				yOff = 2*hoverHeight;
                        }


			hoverLine22.style("opacity", 1);
                        //circleBenchMark22.attr("opacity", 0.4);
                        tipLineChart22.transition().duration(200)
			.style("opacity", 0.7);
                        if ( xCoOrd >= (width22 + margin.left  ))
                                hoverLine22.attr("x1", width22  ).attr("x2", width22 ).style("opacity", 0.5);
                        else
                                hoverLine22.attr("x1", xCoOrd - marOffsetX ).attr("x2", xCoOrd - marOffsetX ).style("opacity", 0.5);
                        locDt = new Date ( xScaler22.invert(xCoOrd - marOffsetX) );
                        var formHtml = '';
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+">" +locDt.getDate()+" "+MnthRev[(locDt.getMonth())+1]+","+locDt.getFullYear() +" </p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+"> (Cumulative Returns) </p></strong>";
                        formHtml += retDailyData( locDt ,".chart22" );


                        tipLineChart22 .html( formHtml)
                                .style("left", (xOff ) + "px")
                                .style("top", (yOff) + "px");

                        // Use event.pageX / event.pageY here

                            var pathLength = benchMarkPath.node().getTotalLength();
                                //console.log("bm length " + pathLength );
                                //since our hover line has an offset from the xAxis our search
                                //needs to begin from there rather than plain xCoord
                                var x = xCoOrd - margin.left;
                                var beginning = x,
                                        end = pathLength,
                                        target;
                                while (true) {
                                        target = Math.floor((beginning + end) / 2);
                                        posBM = benchMarkPath.node().getPointAtLength(target);
                                        if ((target === end || target === beginning) && posBM.x !== x) {
                                                break;
                                        }
                                        if (posBM.x > x) end = target;
                                        else if (posBM.x < x) beginning = target;
                                        else break; //position found
                                }

                                //circleBenchMark22.attr("opacity", 0.5)
                                //        .attr("cx", posBM.x )
                                //        .attr("cy", posBM.y)

                        })  .on("mouseout", function() {
                                console.log('bill');
                                circleBenchMark22.attr("opacity", 0.001);
                                tipLineChart22.transition().duration(200)
				.style("opacity",0);
                                hoverLine22.style("opacity",0);
                  });
                                  // Hover line.

			
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate(0," + height22 + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")
			  .style("text-anchor", "end")
			  .text("Cumulative Change (%)");
		//call the final rendering
		
		_reScaleBM_MF_axes( ".chart22", "FLAT2", 0); 	
		
		
	</script>
	</div>

	</div>

	<div id = "upperHistContainer">
	<div id = "MFHist">
	<svg class="histFlat1"></svg>
        <script>

		genHist(".histFlat1", "FLAT1", 0);
		
	</script>	

	</div>

	<div id = "MFHist">
	
	<svg class="histFlat2"></svg>
        <script>
		genHist(".histFlat2", "FLAT2", 0);

	</script>	
	</div>
	
	</div>


<!-- end container for upper shite -->
</div>

	<div id = "ListTextContainer">
	
	 <div id = "BMList">	
		<label for="search">Another Benchmark ? </label>
		<input id="search">
	</div>



	<div id = "MFvsBMText">
	<div id = "info1">
			<p id="DetailedHeader1"> PlaceHolder </p>
	</div>
	
	<section id="grid" class="grid clearfix">
		<a href="#" data-path-hover="m 180,34.57627 -180,0 L 0,0 180,0 z">
		
		  <!--<svg viewBox="0 0 0 320" preserveAspectRatio="none"><path d="M 180,300 0,300 0,0 180,0 z"/></svg>-->
		  <svg viewBox="0 0 0 320" preserveAspectRatio="none"><path d="M 180,300 0,300 0,0 180,0 z"/></svg>
			<figcaption>
				<h2 id="Header1">PlaceHolder</h2>
				<p id="Header1-Para">PlaceHolder</p>
                 	</figcaption>
		
		</a>	
	</section>
        </div>

	</div>


<!-- lower shite -->
<div id = "lowerHouse">

	<div id = "lowerLCContainer">

	<div id = "MFvsBM1">
	<svg class="chart23" id="OK"></svg>
	<script>	
		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width23 = parseFloat( $("#upperLCContainer").css("width") )/2 - 2*margin.left - 2*margin.right,
                height23 = parseFloat( $("#upperLCContainer").css("height") ) - margin.top - margin.bottom;
		//width = 700 , height = 500 ;
		window.offset23 =  screen.width - parseFloat( $("#upperLCContainer").css("width") ) - margin.left; 
		window.offset23Y =  parseFloat( $("#upperHouse").css("height") ) + margin.top*2 ; 

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler23 = d3.time.scale()
			.range([0, width23]);

		var yScaler23 = d3.scale.linear()
			.range([height23, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler23)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler23)
			.orient("left");

		var svg = d3.select(".chart23")
			.attr("width", width23 + margin.left + margin.right)
			.attr("height", height23 + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
		 //add hover line
                var hoverLineGroup = svg.append("g")
                                  .attr("class", "hover-line");

                window.hoverLine23 = hoverLineGroup
                                .append("line")
                                .attr("x1", 0).attr("x2", 0)
                                .attr("y1", 0).attr("y2", height23)
                                .style("opacity", 0.1);

                  // Hover line.



                d3.select(".chart23")
			.on("mouseover", function() {

                          console.log('mouseover bugs');

                        })
			.on("mousemove", function() {
                          var xCoOrd = d3.mouse(this)[0];
                          var yCoOrd = d3.mouse(this)[1];

			if ( xCoOrd >= (width23 + margin.left +2 )) return 1;
			if ( xCoOrd < margin.left) return 1;

			console.log('DEUCHE '+xCoOrd+' '+yCoOrd);
		  	locData = storeAreaData['.chart23'];
		  	xScaler23.domain(d3.extent( locData.BM  , function(d) { return d.dt; }));
			
                        xOff = offset23;
                        yOff = offset23Y;
                        // no idea why this is needed defaultOffset i mean ..
                        defaultOffset = 20;
                        hoverWidth = parseFloat($('.d3-tip').css("width"));
                        hoverHeight = parseFloat($('.d3-tip').css("height"));

                        if ( (xCoOrd < width23/2) )
                        {
                                xOff = xOff + width23 - hoverWidth + 2*margin.left;
				yOff += 2*hoverHeight;
                        }
			else if ( (xCoOrd >= width23/2) )
                        {
                                xOff = xOff + margin.left + margin.right;// + hoverWidth;
				yOff += 2*hoverHeight;
                        }


			hoverLine23.style("opacity", 1);
                        //circleBenchMark22.attr("opacity", 0.4);
                        tipLineChart22.transition().duration(200)
			.style("opacity", 0.7);
                        if ( xCoOrd >= (width23 + margin.left  ))
                                hoverLine23.attr("x1", width23  ).attr("x2", width23 ).style("opacity", 0.5);
                        else
                                hoverLine23.attr("x1", xCoOrd - marOffsetX ).attr("x2", xCoOrd - marOffsetX ).style("opacity", 0.5);
                        locDt = new Date ( xScaler23.invert(xCoOrd - marOffsetX) );
                        var formHtml = '';
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+">" +locDt.getDate()+" "+MnthRev[(locDt.getMonth())+1]+","+locDt.getFullYear() +" </p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+"> (Cumulative Returns) </p></strong>";
                        formHtml += retDailyData( locDt ,".chart23" );


                        tipLineChart22 .html( formHtml)
                                .style("left", (xOff ) + "px")
                                .style("top", (yOff) + "px");

                        // Use event.pageX / event.pageY here

                        })  .on("mouseout", function() {
                                console.log('bill');
                                tipLineChart22.transition().duration(200)
				.style("opacity",0);
                                hoverLine23.style("opacity",0);
                  });
                                  // Hover line.

			
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate(0," + height23 + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")



		//call the final rendering
		
		_reScaleBM_MF_axes( ".chart23" , "BULL2", 1); 	
		
		
	</script>
	</div>	

	<div id = "MFvsBM1">
	
	<svg class="chart24" id="OK"></svg>
	<script>	
		var margin = {top: 20, right: 30, bottom: 20, left: 30},
		width24 = parseFloat( $("#upperLCContainer").css("width") )/2 - 2*margin.left - 2*margin.right,
                height24 = parseFloat( $("#upperLCContainer").css("height") ) - margin.top - margin.bottom;
		//width = 700 , height = 500 ;
		window.offset24 =  screen.width - (parseFloat( $("#upperLCContainer").css("width") )/2) - margin.left; 
		window.offset24Y =  parseFloat( $("#upperHouse").css("height") ) + margin.top*2 ; 

		var parsedt = d3.time.format("%d-%b-%y").parse;
		//hopefully store dragslider values
		window.marOffsetX = margin.right;
		window.marOffsetY = margin.top;
		
		var xScaler24 = d3.time.scale()
			.range([0, width24]);

		var yScaler24 = d3.scale.linear()
			.range([height24, 0]);

		var xAxis = d3.svg.axis()
			.scale(xScaler24)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScaler24)
			.orient("left");

		var svg = d3.select(".chart24")
			.attr("width", width24 + margin.left + margin.right)
			.attr("height", height24 + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + (margin.top) + ")");
		 //add hover line
                var hoverLineGroup = svg.append("g")
                                  .attr("class", "hover-line");

                window.hoverLine24 = hoverLineGroup
                                .append("line")
                                .attr("x1", 0).attr("x2", 0)
                                .attr("y1", 0).attr("y2", height24)
                                .style("opacity", 0.1);

                  // Hover line.



                d3.select(".chart24")
			.on("mouseover", function() {

                          console.log('mouseover bugs');

                        })
			.on("mousemove", function() {
                          var xCoOrd = d3.mouse(this)[0];
                          var yCoOrd = d3.mouse(this)[1];

			if ( xCoOrd >= (width24 + margin.left +2 )) return 1;
			if ( xCoOrd < margin.left) return 1;

			console.log('DEUCHE '+xCoOrd+' '+yCoOrd);
		  	locData = storeAreaData['.chart24'];
		  	xScaler24.domain(d3.extent( locData.BM  , function(d) { return d.dt; }));
			
                        xOff = offset24;
                        yOff = offset24Y ;
                        // no idea why this is needed defaultOffset i mean ..
                        defaultOffset = 20;
                        hoverWidth = parseFloat($('.d3-tip').css("width"));
                        hoverHeight = parseFloat($('.d3-tip').css("height"));

                        if ( (xCoOrd < width24/2) )
                        {
                                xOff = xOff + width24 - hoverWidth + 2*margin.left;
				yOff += 2*hoverHeight;
                        }
			else if ( (xCoOrd >= width24/2) )
                        {
                                xOff = xOff + margin.left + margin.right;// + hoverWidth;
				yOff += 2*hoverHeight;
                        }


			hoverLine24.style("opacity", 1);
                        //circleBenchMark22.attr("opacity", 0.4);
                        tipLineChart22.transition().duration(200)
			.style("opacity", 0.7);
                        if ( xCoOrd >= (width24 + margin.left  ))
                                hoverLine24.attr("x1", width24  ).attr("x2", width24 ).style("opacity", 0.5);
                        else
                                hoverLine24.attr("x1", xCoOrd - marOffsetX ).attr("x2", xCoOrd - marOffsetX ).style("opacity", 0.5);
                        locDt = new Date ( xScaler24.invert(xCoOrd - marOffsetX) );
                        var formHtml = '';
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+">" +locDt.getDate()+" "+MnthRev[(locDt.getMonth())+1]+","+locDt.getFullYear() +" </p></strong>";
                        formHtml +=  "<strong><p style="+"\"color:steelblue\""+"> (Cumulative Returns) </p></strong>";
                        formHtml += retDailyData( locDt ,".chart24" );


                        tipLineChart22 .html( formHtml)
                                .style("left", (xOff ) + "px")
                                .style("top", (yOff) + "px");

                        // Use event.pageX / event.pageY here

                        })  .on("mouseout", function() {
                                console.log('bill');
                                tipLineChart22.transition().duration(200)
				.style("opacity",0);
                                hoverLine24.style("opacity",0);
                  });
                                  // Hover line.

			
		  svg.append("g")
			  .attr("class", "x axis")
			  .attr("transform", "translate(0," + height24 + ")")
			  .call(xAxis);

		  svg.append("g")
			  .attr("class", "y axis")
			  .call(yAxis)
			  .append("text")
			  .attr("transform", "rotate(-90)")
			  .attr("y", 2)
			  .attr("dy", "1em")



		//call the final rendering
		
		_reScaleBM_MF_axes(".chart24", "BULL3", 0); 	
		
		
	</script>
	</div>
	
	</div>

	<div id = "lowerHistContainer">
	
	<div id = "MFHist1">
	<svg class="histFlat3"></svg>
        <script>

		genHist(".histFlat3", "BULL2", 1);

	</script>	

	</div>

	<div id = "MFHist1">
	
	<svg class="histFlat4"></svg>
        <script>

		genHist(".histFlat4", "BULL3", 1);
		//now call the message geerator
		genMsg();		
	</script>	
	</div>
	
<!-- lower shite -->
</div>

	<script>
	  $(function() {
		window.locList = [];
		for (idx = 0;idx < distSeries.length;idx++){
			locList.push(distSeries[idx]['idx_name']);
		} 
 
		$( "#search" ).autocomplete({
		  delay: 0,
		  source: locList,
		  select: function(event, ui) { 
		  //callback when option is selected
			console.log(ui.item.label)  ;
			$("#loader-wrapper").show();
			$.ajax({
        			type: "POST",
        			url: "http://ec2-52-77-217-54.ap-southeast-1.compute.amazonaws.com:8000/polls/",  // or just url: "/my-url/path/"
        			data: {
            				csrfmiddlewaretoken: '{{ csrf_token }}' ,
            				idx: ui.item.label
        			},
        			success: function(data) {
					$("#loader-wrapper").hide();
            				console.log("Congratulations! You scored: "+ data);
					var parsed = JSON.parse(data);
					refreshWithLatest(parsed);
				
        			},
        			error: function(xhr, textStatus, errorThrown) {
            				alert("Please report this error: "+errorThrown+xhr.status+xhr.responseText);
        			}
    			});
		  }
		});
		
	  });

	$.widget( "custom.catcomplete", $.ui.autocomplete, {
		_create: function() {
		  this._super();
		  this.widget().menu( "option", "items", "> :not(.ui-autocomplete-category)" );
		},
		_renderMenu: function( ul, items ) {
		  var that = this,
			currentCategory = "";
		  $.each( items, function( index, item ) {
			var li;
			if ( item.category != currentCategory ) {
			  ul.append( "<li class='ui-autocomplete-category'>" + item.category + "</li>" );
			  currentCategory = item.category;
			}
			li = that._renderItemData( ul, item );
			if ( item.category ) {
			  li.attr( "aria-label", item.category + " : " + item.label );
			}
		  });
		}
		
	  });
	  
  	</script>

	<script>
			(function() {
	
				function init() {
					var speed = 50,
						easing = mina.easeinout;

					[].slice.call ( document.querySelectorAll( '#grid > a' ) ).forEach( function( el ) {
						var s = Snap( el.querySelector( 'svg' ) ), path = s.select( 'path' ),
							pathConfig = {
								from : path.attr( 'd' ),
								to : el.getAttribute( 'data-path-hover' )
							};

						el.addEventListener( 'mouseenter', function() {
							path.animate( { 'path' : pathConfig.to }, speed, easing );
							$("#info1").fadeIn();
							$("#HDR").fadeIn();
						} );

						el.addEventListener( 'mouseleave', function() {
							path.animate( { 'path' : pathConfig.from }, speed, easing );
							$("#info1").hide();
							$("#HDR").hide();
						} );
					} );
				}

				init();

			})();


		(function() {
    				document.onmousemove = handleMouseMove;
    					function handleMouseMove(event) {
        				var dot, eventDoc, doc, body, pageX, pageY;

        				event = event || window.event; // IE-ism

        // If pageX/Y aren't available and clientX/Y are,
        // calculate pageX/Y - logic taken from jQuery.
        // (This is to support old IE)
        				if (event.pageX == null && event.clientX != null) {
            					eventDoc = (event.target && event.target.ownerDocument) || document;
            					doc = eventDoc.documentElement;
           					 body = eventDoc.body;

            					event.pageX = event.clientX +
              						(doc && doc.scrollLeft || body && body.scrollLeft || 0) -
              						(doc && doc.clientLeft || body && body.clientLeft || 0);
            					event.pageY = event.clientY +
              						(doc && doc.scrollTop  || body && body.scrollTop  || 0) -
              						(doc && doc.clientTop  || body && body.clientTop  || 0 );
        				}

        // Use event.pageX / event.pageY here
    				      }
		     })();
	</script>
	
</body>
